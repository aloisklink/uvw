<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uvw: uvw::tcp_handle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">uvw<span id="projectnumber">&#160;3.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceuvw.html">uvw</a></li><li class="navelem"><a class="el" href="classuvw_1_1tcp__handle.html">tcp_handle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classuvw_1_1tcp__handle-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">uvw::tcp_handle Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The TCP handle.  
 <a href="classuvw_1_1tcp__handle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tcp_8h_source.html">tcp.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for uvw::tcp_handle:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1tcp__handle__inherit__graph.png" border="0" usemap="#auvw_1_1tcp__handle_inherit__map" alt="Inheritance graph"/></div>
<map name="auvw_1_1tcp__handle_inherit__map" id="auvw_1_1tcp__handle_inherit__map">
<area shape="rect" title="The TCP handle." alt="" coords="93,328,208,353"/>
<area shape="rect" href="classuvw_1_1stream__handle.html" title=" " alt="" coords="68,240,233,280"/>
<area shape="rect" href="classuvw_1_1handle.html" title="Handle base class." alt="" coords="73,167,228,192"/>
<area shape="rect" href="classuvw_1_1resource.html" title=" " alt="" coords="80,79,221,119"/>
<area shape="rect" href="structuvw_1_1uv__type.html" title="Wrapper class for underlying types." alt="" coords="5,5,133,31"/>
<area shape="rect" href="classuvw_1_1emitter.html" title=" " alt="" coords="158,5,309,31"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for uvw::tcp_handle:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1tcp__handle__coll__graph.png" border="0" usemap="#auvw_1_1tcp__handle_coll__map" alt="Collaboration graph"/></div>
<map name="auvw_1_1tcp__handle_coll__map" id="auvw_1_1tcp__handle_coll__map">
<area shape="rect" title="The TCP handle." alt="" coords="93,328,208,353"/>
<area shape="rect" href="classuvw_1_1stream__handle.html" title=" " alt="" coords="68,240,233,280"/>
<area shape="rect" href="classuvw_1_1handle.html" title="Handle base class." alt="" coords="73,167,228,192"/>
<area shape="rect" href="classuvw_1_1resource.html" title=" " alt="" coords="80,79,221,119"/>
<area shape="rect" href="structuvw_1_1uv__type.html" title="Wrapper class for underlying types." alt="" coords="5,5,133,31"/>
<area shape="rect" href="classuvw_1_1emitter.html" title=" " alt="" coords="158,5,309,31"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0cb5490996adb8ae112927a036aee85d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1tcp__handle.html#a0cb5490996adb8ae112927a036aee85d">init</a> () final</td></tr>
<tr class="memdesc:a0cb5490996adb8ae112927a036aee85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the handle. No socket is created as of yet.  <br /></td></tr>
<tr class="separator:a0cb5490996adb8ae112927a036aee85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6471fd78e04097d697f377a09f21b074"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1tcp__handle.html#a6471fd78e04097d697f377a09f21b074">open</a> (<a class="el" href="namespaceuvw.html#aa64a7948231fbdec46df43be0c24f806">os_socket_handle</a> socket)</td></tr>
<tr class="memdesc:a6471fd78e04097d697f377a09f21b074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing file descriptor or SOCKET as a TCP handle.  <br /></td></tr>
<tr class="separator:a6471fd78e04097d697f377a09f21b074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c83d92ee6ace5631592b361b14cfc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1tcp__handle.html#ab6c83d92ee6ace5631592b361b14cfc0">no_delay</a> (bool value=false)</td></tr>
<tr class="memdesc:ab6c83d92ee6ace5631592b361b14cfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/Disables Nagleâ€™s algorithm.  <br /></td></tr>
<tr class="separator:ab6c83d92ee6ace5631592b361b14cfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b637f533caff624152860f403a3ce2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1tcp__handle.html#a03b637f533caff624152860f403a3ce2">keep_alive</a> (bool enable=false, time val=time{0})</td></tr>
<tr class="memdesc:a03b637f533caff624152860f403a3ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/Disables TCP keep-alive.  <br /></td></tr>
<tr class="separator:a03b637f533caff624152860f403a3ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99480e7a5d3ece02605268da008ecb4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1tcp__handle.html#a99480e7a5d3ece02605268da008ecb4d">simultaneous_accepts</a> (bool enable=true)</td></tr>
<tr class="memdesc:a99480e7a5d3ece02605268da008ecb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/Disables simultaneous asynchronous accept requests.  <br /></td></tr>
<tr class="separator:a99480e7a5d3ece02605268da008ecb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca6004d021abc9bab6340d8b7371c02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1tcp__handle.html#a2ca6004d021abc9bab6340d8b7371c02">bind</a> (const sockaddr &amp;addr, tcp_flags opts=tcp_flags::_UVW_ENUM)</td></tr>
<tr class="memdesc:a2ca6004d021abc9bab6340d8b7371c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the handle to an address and port.  <br /></td></tr>
<tr class="separator:a2ca6004d021abc9bab6340d8b7371c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305d6d18160ca1c896e95cf77c5c8475"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1tcp__handle.html#a305d6d18160ca1c896e95cf77c5c8475">bind</a> (const std::string &amp;ip, unsigned int port, tcp_flags opts=tcp_flags::_UVW_ENUM)</td></tr>
<tr class="memdesc:a305d6d18160ca1c896e95cf77c5c8475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the handle to an address and port.  <br /></td></tr>
<tr class="separator:a305d6d18160ca1c896e95cf77c5c8475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade65abcde580bdf8458512966d16deb4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1tcp__handle.html#ade65abcde580bdf8458512966d16deb4">bind</a> (<a class="el" href="structuvw_1_1socket__address.html">socket_address</a> addr, tcp_flags opts=tcp_flags::_UVW_ENUM)</td></tr>
<tr class="memdesc:ade65abcde580bdf8458512966d16deb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds the handle to an address and port.  <br /></td></tr>
<tr class="separator:ade65abcde580bdf8458512966d16deb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dc0685013fc8fb3e1c9effabdda4d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structuvw_1_1socket__address.html">socket_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1tcp__handle.html#ad9dc0685013fc8fb3e1c9effabdda4d2">sock</a> () const noexcept</td></tr>
<tr class="memdesc:ad9dc0685013fc8fb3e1c9effabdda4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current address to which the handle is bound.  <br /></td></tr>
<tr class="separator:ad9dc0685013fc8fb3e1c9effabdda4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02b6d53c63af19d7a972c4b9d950e17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structuvw_1_1socket__address.html">socket_address</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1tcp__handle.html#ac02b6d53c63af19d7a972c4b9d950e17">peer</a> () const noexcept</td></tr>
<tr class="memdesc:ac02b6d53c63af19d7a972c4b9d950e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the address of the peer connected to the handle.  <br /></td></tr>
<tr class="separator:ac02b6d53c63af19d7a972c4b9d950e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36226129a77639858cc152080c00442a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1tcp__handle.html#a36226129a77639858cc152080c00442a">connect</a> (const sockaddr &amp;addr)</td></tr>
<tr class="memdesc:a36226129a77639858cc152080c00442a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes an IPv4 or IPv6 TCP connection.  <br /></td></tr>
<tr class="separator:a36226129a77639858cc152080c00442a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ce16492f9094bc80514b5852de2f97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1tcp__handle.html#af1ce16492f9094bc80514b5852de2f97">connect</a> (const std::string &amp;ip, unsigned int port)</td></tr>
<tr class="memdesc:af1ce16492f9094bc80514b5852de2f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes an IPv4 or IPv6 TCP connection.  <br /></td></tr>
<tr class="separator:af1ce16492f9094bc80514b5852de2f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f458a7a7883768e6514e24fcd6c1077"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1tcp__handle.html#a0f458a7a7883768e6514e24fcd6c1077">connect</a> (<a class="el" href="structuvw_1_1socket__address.html">socket_address</a> addr)</td></tr>
<tr class="memdesc:a0f458a7a7883768e6514e24fcd6c1077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes an IPv4 or IPv6 TCP connection.  <br /></td></tr>
<tr class="separator:a0f458a7a7883768e6514e24fcd6c1077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5737d2d58f61d266be2e8fb7d3057838"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1tcp__handle.html#a5737d2d58f61d266be2e8fb7d3057838">close_reset</a> ()</td></tr>
<tr class="memdesc:a5737d2d58f61d266be2e8fb7d3057838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a TCP connection by sending a RST packet.  <br /></td></tr>
<tr class="separator:a5737d2d58f61d266be2e8fb7d3057838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1stream__handle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1stream__handle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle&lt; tcp_handle, uv_tcp_t &gt;</a></td></tr>
<tr class="memitem:a74a48d00b23a4bd5a231d3f8bfaa655d inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a74a48d00b23a4bd5a231d3f8bfaa655d">shutdown</a> ()</td></tr>
<tr class="memdesc:a74a48d00b23a4bd5a231d3f8bfaa655d inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdowns the outgoing (write) side of a duplex stream.  <br /></td></tr>
<tr class="separator:a74a48d00b23a4bd5a231d3f8bfaa655d inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1022648bbcdd62fa84a411aa80c1057 inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#ae1022648bbcdd62fa84a411aa80c1057">listen</a> (int backlog=DEFAULT_BACKLOG)</td></tr>
<tr class="memdesc:ae1022648bbcdd62fa84a411aa80c1057 inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts listening for incoming connections.  <br /></td></tr>
<tr class="separator:ae1022648bbcdd62fa84a411aa80c1057 inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005a77de769d10b660c198478ae03dba inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a005a77de769d10b660c198478ae03dba">accept</a> (S &amp;ref)</td></tr>
<tr class="memdesc:a005a77de769d10b660c198478ae03dba inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts incoming connections.  <br /></td></tr>
<tr class="separator:a005a77de769d10b660c198478ae03dba inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb471cfc6eec1dc2683e381ec828087 inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a1fb471cfc6eec1dc2683e381ec828087">read</a> ()</td></tr>
<tr class="memdesc:a1fb471cfc6eec1dc2683e381ec828087 inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts reading data from an incoming stream.  <br /></td></tr>
<tr class="separator:a1fb471cfc6eec1dc2683e381ec828087 inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06ccaed032ab19ac2466ba35c5d1c9e inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#ae06ccaed032ab19ac2466ba35c5d1c9e">stop</a> ()</td></tr>
<tr class="memdesc:ae06ccaed032ab19ac2466ba35c5d1c9e inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops reading data from the stream.  <br /></td></tr>
<tr class="separator:ae06ccaed032ab19ac2466ba35c5d1c9e inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a3ac704e013ede496a3d998a74ebc7 inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#ad8a3ac704e013ede496a3d998a74ebc7">write</a> (std::unique_ptr&lt; char[], Deleter &gt; data, unsigned int len)</td></tr>
<tr class="memdesc:ad8a3ac704e013ede496a3d998a74ebc7 inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the stream.  <br /></td></tr>
<tr class="separator:ad8a3ac704e013ede496a3d998a74ebc7 inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0895fadb7985f8b437ff3bce62a80b inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#afd0895fadb7985f8b437ff3bce62a80b">write</a> (char *data, unsigned int len)</td></tr>
<tr class="memdesc:afd0895fadb7985f8b437ff3bce62a80b inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the stream.  <br /></td></tr>
<tr class="separator:afd0895fadb7985f8b437ff3bce62a80b inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a943387b69c05b7bb6469f7042ca08 inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a28a943387b69c05b7bb6469f7042ca08">write</a> (S &amp;send, std::unique_ptr&lt; char[], Deleter &gt; data, unsigned int len)</td></tr>
<tr class="memdesc:a28a943387b69c05b7bb6469f7042ca08 inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended write function for sending handles over a pipe handle.  <br /></td></tr>
<tr class="separator:a28a943387b69c05b7bb6469f7042ca08 inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace2532231266f660ad26876602eaad0 inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#aace2532231266f660ad26876602eaad0">write</a> (S &amp;send, char *data, unsigned int len)</td></tr>
<tr class="memdesc:aace2532231266f660ad26876602eaad0 inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended write function for sending handles over a pipe handle.  <br /></td></tr>
<tr class="separator:aace2532231266f660ad26876602eaad0 inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07b07065609821932537dc23773b2ed inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#af07b07065609821932537dc23773b2ed">try_write</a> (std::unique_ptr&lt; char[]&gt; data, unsigned int len)</td></tr>
<tr class="memdesc:af07b07065609821932537dc23773b2ed inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a write request if it can be completed immediately.  <br /></td></tr>
<tr class="separator:af07b07065609821932537dc23773b2ed inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b12e5126cba8c84a3fdbb01cc3b81a inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#aa0b12e5126cba8c84a3fdbb01cc3b81a">try_write</a> (std::unique_ptr&lt; char[]&gt; data, unsigned int len, <a class="el" href="classuvw_1_1stream__handle.html">stream_handle</a>&lt; V, W &gt; &amp;send)</td></tr>
<tr class="memdesc:aa0b12e5126cba8c84a3fdbb01cc3b81a inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a write request if it can be completed immediately.  <br /></td></tr>
<tr class="separator:aa0b12e5126cba8c84a3fdbb01cc3b81a inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d56a5108fd6f3fd7f11f7e5507c7727 inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a6d56a5108fd6f3fd7f11f7e5507c7727">try_write</a> (char *data, unsigned int len)</td></tr>
<tr class="memdesc:a6d56a5108fd6f3fd7f11f7e5507c7727 inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a write request if it can be completed immediately.  <br /></td></tr>
<tr class="separator:a6d56a5108fd6f3fd7f11f7e5507c7727 inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729ff5d6b7da6af3c70068a3dfca5204 inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a729ff5d6b7da6af3c70068a3dfca5204">try_write</a> (char *data, unsigned int len, <a class="el" href="classuvw_1_1stream__handle.html">stream_handle</a>&lt; V, W &gt; &amp;send)</td></tr>
<tr class="memdesc:a729ff5d6b7da6af3c70068a3dfca5204 inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a write request if it can be completed immediately.  <br /></td></tr>
<tr class="separator:a729ff5d6b7da6af3c70068a3dfca5204 inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459eccecaee81d4a8619e1a073e81a69 inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a459eccecaee81d4a8619e1a073e81a69">readable</a> () const noexcept</td></tr>
<tr class="memdesc:a459eccecaee81d4a8619e1a073e81a69 inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream is readable.  <br /></td></tr>
<tr class="separator:a459eccecaee81d4a8619e1a073e81a69 inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ac22ea79bf27479eedbda9ac1101f0 inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a09ac22ea79bf27479eedbda9ac1101f0">writable</a> () const noexcept</td></tr>
<tr class="memdesc:a09ac22ea79bf27479eedbda9ac1101f0 inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream is writable.  <br /></td></tr>
<tr class="separator:a09ac22ea79bf27479eedbda9ac1101f0 inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824348c23445390d58fb393f731acdee inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a824348c23445390d58fb393f731acdee">blocking</a> (bool enable=false)</td></tr>
<tr class="memdesc:a824348c23445390d58fb393f731acdee inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables blocking mode for a stream.  <br /></td></tr>
<tr class="separator:a824348c23445390d58fb393f731acdee inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455c3e4cccd8f8119d1f251b809ea810 inherit pub_methods_classuvw_1_1stream__handle"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a455c3e4cccd8f8119d1f251b809ea810">write_queue_size</a> () const noexcept</td></tr>
<tr class="memdesc:a455c3e4cccd8f8119d1f251b809ea810 inherit pub_methods_classuvw_1_1stream__handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the amount of queued bytes waiting to be sent.  <br /></td></tr>
<tr class="separator:a455c3e4cccd8f8119d1f251b809ea810 inherit pub_methods_classuvw_1_1stream__handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1handle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1handle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1handle.html">uvw::handle&lt; T, U, E &gt;</a></td></tr>
<tr class="memitem:a80c5ba8c4db128cc525406e998549b96 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#a9e28e1855691dd1af105626ed11f3ac4">handle_category</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a80c5ba8c4db128cc525406e998549b96">category</a> () const noexcept</td></tr>
<tr class="memdesc:a80c5ba8c4db128cc525406e998549b96 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the category of the handle.  <br /></td></tr>
<tr class="separator:a80c5ba8c4db128cc525406e998549b96 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88018be1fa3105e958c50a9f1881baa9 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#a3954d5751b5b6ebb0c90c195e9b94edd">handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a88018be1fa3105e958c50a9f1881baa9">type</a> () const noexcept</td></tr>
<tr class="memdesc:a88018be1fa3105e958c50a9f1881baa9 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the handle.  <br /></td></tr>
<tr class="separator:a88018be1fa3105e958c50a9f1881baa9 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938d3ac6e5cc78f9442f9bb851170643 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a938d3ac6e5cc78f9442f9bb851170643">active</a> () const noexcept</td></tr>
<tr class="memdesc:a938d3ac6e5cc78f9442f9bb851170643 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the handle is active.  <br /></td></tr>
<tr class="separator:a938d3ac6e5cc78f9442f9bb851170643 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93cbf2156f0d673093e48832104a3cc inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#ae93cbf2156f0d673093e48832104a3cc">closing</a> () const noexcept</td></tr>
<tr class="memdesc:ae93cbf2156f0d673093e48832104a3cc inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a handle is closing or closed.  <br /></td></tr>
<tr class="separator:ae93cbf2156f0d673093e48832104a3cc inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3648ed9805e8d0e8963f137f8584e483 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a3648ed9805e8d0e8963f137f8584e483">close</a> () noexcept</td></tr>
<tr class="memdesc:a3648ed9805e8d0e8963f137f8584e483 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request handle to be closed.  <br /></td></tr>
<tr class="separator:a3648ed9805e8d0e8963f137f8584e483 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0d788997368ab1af2dc475126a46d2 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a2f0d788997368ab1af2dc475126a46d2">reference</a> () noexcept</td></tr>
<tr class="memdesc:a2f0d788997368ab1af2dc475126a46d2 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference the given handle.  <br /></td></tr>
<tr class="separator:a2f0d788997368ab1af2dc475126a46d2 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a91d1353c19f1a05aace78dc2cc453 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a83a91d1353c19f1a05aace78dc2cc453">unreference</a> () noexcept</td></tr>
<tr class="memdesc:a83a91d1353c19f1a05aace78dc2cc453 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unreference the given handle.  <br /></td></tr>
<tr class="separator:a83a91d1353c19f1a05aace78dc2cc453 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1403f961ab40063f79c4a293c78ed63c inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a1403f961ab40063f79c4a293c78ed63c">referenced</a> () const noexcept</td></tr>
<tr class="memdesc:a1403f961ab40063f79c4a293c78ed63c inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given handle referenced.  <br /></td></tr>
<tr class="separator:a1403f961ab40063f79c4a293c78ed63c inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5852080ba1fd71a302c2424cf2df9a27 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a5852080ba1fd71a302c2424cf2df9a27">size</a> () const noexcept</td></tr>
<tr class="memdesc:a5852080ba1fd71a302c2424cf2df9a27 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the underlying handle type.  <br /></td></tr>
<tr class="separator:a5852080ba1fd71a302c2424cf2df9a27 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99406ca909aeaac17522959db8c71a4 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#aa99406ca909aeaac17522959db8c71a4">send_buffer_size</a> ()</td></tr>
<tr class="memdesc:aa99406ca909aeaac17522959db8c71a4 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the send buffer used for the socket.  <br /></td></tr>
<tr class="separator:aa99406ca909aeaac17522959db8c71a4 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917ab9c1f011232b50f9980f29167ee2 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a917ab9c1f011232b50f9980f29167ee2">send_buffer_size</a> (int value)</td></tr>
<tr class="memdesc:a917ab9c1f011232b50f9980f29167ee2 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the send buffer used for the socket.  <br /></td></tr>
<tr class="separator:a917ab9c1f011232b50f9980f29167ee2 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3337ef0c68ed5ba0e9bea0e2e90539 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a7a3337ef0c68ed5ba0e9bea0e2e90539">recv_buffer_size</a> ()</td></tr>
<tr class="memdesc:a7a3337ef0c68ed5ba0e9bea0e2e90539 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the receive buffer used for the socket.  <br /></td></tr>
<tr class="separator:a7a3337ef0c68ed5ba0e9bea0e2e90539 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace23bb725f6f80ae7a611f5228ad9f8d inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#ace23bb725f6f80ae7a611f5228ad9f8d">recv_buffer_size</a> (int value)</td></tr>
<tr class="memdesc:ace23bb725f6f80ae7a611f5228ad9f8d inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the receive buffer used for the socket.  <br /></td></tr>
<tr class="separator:ace23bb725f6f80ae7a611f5228ad9f8d inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce9568c94aa0122ff4cee6a57b4fae5 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#a1a4f79e341b89257a11403ee0739f2b4">os_file_descriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a0ce9568c94aa0122ff4cee6a57b4fae5">fd</a> () const</td></tr>
<tr class="memdesc:a0ce9568c94aa0122ff4cee6a57b4fae5 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the platform dependent file descriptor equivalent.  <br /></td></tr>
<tr class="separator:a0ce9568c94aa0122ff4cee6a57b4fae5 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1resource"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1resource')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1resource.html">uvw::resource&lt; T, U, close_event, E... &gt;</a></td></tr>
<tr class="memitem:a7c05e988ebaa14d1dbbc781951dc3a88 inherit pub_methods_classuvw_1_1resource"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1resource.html#a7c05e988ebaa14d1dbbc781951dc3a88">data</a> () const</td></tr>
<tr class="memdesc:a7c05e988ebaa14d1dbbc781951dc3a88 inherit pub_methods_classuvw_1_1resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets user-defined data. <code>uvw</code> won't use this field in any case.  <br /></td></tr>
<tr class="separator:a7c05e988ebaa14d1dbbc781951dc3a88 inherit pub_methods_classuvw_1_1resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759079eb405e5d2fda795d199d8efa80 inherit pub_methods_classuvw_1_1resource"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1resource.html#a759079eb405e5d2fda795d199d8efa80">data</a> (std::shared_ptr&lt; void &gt; udata)</td></tr>
<tr class="memdesc:a759079eb405e5d2fda795d199d8efa80 inherit pub_methods_classuvw_1_1resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets arbitrary data. <code>uvw</code> won't use this field in any case.  <br /></td></tr>
<tr class="separator:a759079eb405e5d2fda795d199d8efa80 inherit pub_methods_classuvw_1_1resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structuvw_1_1uv__type"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structuvw_1_1uv__type')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structuvw_1_1uv__type.html">uvw::uv_type&lt; U &gt;</a></td></tr>
<tr class="memitem:ae97ffacc0b381610d8d18a62a957a69c inherit pub_methods_structuvw_1_1uv__type"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1uv__type.html#ae97ffacc0b381610d8d18a62a957a69c">init</a> ()</td></tr>
<tr class="memdesc:ae97ffacc0b381610d8d18a62a957a69c inherit pub_methods_structuvw_1_1uv__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the handle.  <br /></td></tr>
<tr class="separator:ae97ffacc0b381610d8d18a62a957a69c inherit pub_methods_structuvw_1_1uv__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03b0ebbae151c6157c5ba6a24a39a7b inherit pub_methods_structuvw_1_1uv__type"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuvw_1_1loop.html">loop</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1uv__type.html#ae03b0ebbae151c6157c5ba6a24a39a7b">parent</a> () const noexcept</td></tr>
<tr class="memdesc:ae03b0ebbae151c6157c5ba6a24a39a7b inherit pub_methods_structuvw_1_1uv__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the loop from which the resource was originated.  <br /></td></tr>
<tr class="separator:ae03b0ebbae151c6157c5ba6a24a39a7b inherit pub_methods_structuvw_1_1uv__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a6cb7ebde27aa348e340b76e49c6ae inherit pub_methods_structuvw_1_1uv__type"><td class="memItemLeft" align="right" valign="top">const U *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1uv__type.html#a06a6cb7ebde27aa348e340b76e49c6ae">raw</a> () const noexcept</td></tr>
<tr class="memdesc:a06a6cb7ebde27aa348e340b76e49c6ae inherit pub_methods_structuvw_1_1uv__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <br /></td></tr>
<tr class="separator:a06a6cb7ebde27aa348e340b76e49c6ae inherit pub_methods_structuvw_1_1uv__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b6f395815f2e99302b5f09be23767c inherit pub_methods_structuvw_1_1uv__type"><td class="memItemLeft" align="right" valign="top">U *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1uv__type.html#af4b6f395815f2e99302b5f09be23767c">raw</a> () noexcept</td></tr>
<tr class="memdesc:af4b6f395815f2e99302b5f09be23767c inherit pub_methods_structuvw_1_1uv__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <br /></td></tr>
<tr class="separator:af4b6f395815f2e99302b5f09be23767c inherit pub_methods_structuvw_1_1uv__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1emitter"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1emitter')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1emitter.html">uvw::emitter&lt; T, E... &gt;</a></td></tr>
<tr class="memitem:ab913fa1c005a33c73b2eb2b0d1051b1f inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1emitter.html#ab913fa1c005a33c73b2eb2b0d1051b1f">on</a> (listener_t&lt; U &gt; f)</td></tr>
<tr class="memdesc:ab913fa1c005a33c73b2eb2b0d1051b1f inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a long-lived listener with the event emitter.  <br /></td></tr>
<tr class="separator:ab913fa1c005a33c73b2eb2b0d1051b1f inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accff5c096692f5eebbe941189644e69d inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top"><a id="accff5c096692f5eebbe941189644e69d" name="accff5c096692f5eebbe941189644e69d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> () noexcept</td></tr>
<tr class="memdesc:accff5c096692f5eebbe941189644e69d inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects the listener for the given event type. <br /></td></tr>
<tr class="separator:accff5c096692f5eebbe941189644e69d inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71435e74e775cfa7012fe2e52ca5193 inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top"><a id="aa71435e74e775cfa7012fe2e52ca5193" name="aa71435e74e775cfa7012fe2e52ca5193"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> () noexcept</td></tr>
<tr class="memdesc:aa71435e74e775cfa7012fe2e52ca5193 inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects all listeners. <br /></td></tr>
<tr class="separator:aa71435e74e775cfa7012fe2e52ca5193 inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02a29fe156faba7571b50450fc4f780 inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1emitter.html#ac02a29fe156faba7571b50450fc4f780">has</a> () const noexcept</td></tr>
<tr class="memdesc:ac02a29fe156faba7571b50450fc4f780 inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is a listener registered for the specific event.  <br /></td></tr>
<tr class="separator:ac02a29fe156faba7571b50450fc4f780 inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The TCP handle. </p>
<p>TCP handles are used to represent both TCP streams and servers.<br  />
 By default, <em><a class="el" href="structuvw_1_1ipv4.html" title="The IPv4 tag.">ipv4</a></em> is used as a template parameter. The handle already supports <em>IPv6</em> out-of-the-box by using <code><a class="el" href="structuvw_1_1ipv6.html" title="The IPv6 tag.">uvw::ipv6</a></code>.</p>
<p>To create a <code><a class="el" href="classuvw_1_1tcp__handle.html" title="The TCP handle.">tcp_handle</a></code> through a <code>loop</code>, arguments follow:</p>
<ul>
<li>An optional integer value that indicates the flags used to initialize the socket.</li>
</ul>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/tcp.html#c.uv_tcp_init_ex">documentation</a> for further details. </p>

<p class="definition">Definition at line <a class="el" href="tcp_8h_source.html#l00043">43</a> of file <a class="el" href="tcp_8h_source.html">tcp.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2ca6004d021abc9bab6340d8b7371c02" name="a2ca6004d021abc9bab6340d8b7371c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca6004d021abc9bab6340d8b7371c02">&#9670;&#160;</a></span>bind() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uvw::tcp_handle::bind </td>
          <td>(</td>
          <td class="paramtype">const sockaddr &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tcp_flags&#160;</td>
          <td class="paramname"><em>opts</em> = <code>tcp_flags::_UVW_ENUM</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the handle to an address and port. </p>
<p>A successful call to this function does not guarantee that the call to <code><a class="el" href="classuvw_1_1stream__handle.html#ae1022648bbcdd62fa84a411aa80c1057" title="Starts listening for incoming connections.">listen()</a></code> or <code><a class="el" href="classuvw_1_1tcp__handle.html#a36226129a77639858cc152080c00442a" title="Establishes an IPv4 or IPv6 TCP connection.">connect()</a></code> will work properly.</p>
<p>Available flags are:</p>
<ul>
<li><code>tcp_handle::tcp_flags::IPV6ONLY</code>: it disables dual-stack support and only IPv6 is used.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Initialized <code>sockaddr_in</code> or <code>sockaddr_in6</code> data structure. </td></tr>
    <tr><td class="paramname">opts</td><td>Optional additional flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

</div>
</div>
<a id="a305d6d18160ca1c896e95cf77c5c8475" name="a305d6d18160ca1c896e95cf77c5c8475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305d6d18160ca1c896e95cf77c5c8475">&#9670;&#160;</a></span>bind() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uvw::tcp_handle::bind </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tcp_flags&#160;</td>
          <td class="paramname"><em>opts</em> = <code>tcp_flags::_UVW_ENUM</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the handle to an address and port. </p>
<p>A successful call to this function does not guarantee that the call to <code><a class="el" href="classuvw_1_1stream__handle.html#ae1022648bbcdd62fa84a411aa80c1057" title="Starts listening for incoming connections.">listen()</a></code> or <code><a class="el" href="classuvw_1_1tcp__handle.html#a36226129a77639858cc152080c00442a" title="Establishes an IPv4 or IPv6 TCP connection.">connect()</a></code> will work properly.</p>
<p>Available flags are:</p>
<ul>
<li><code>tcp_handle::tcp_flags::IPV6ONLY</code>: it disables dual-stack support and only IPv6 is used.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The address to which to bind. </td></tr>
    <tr><td class="paramname">port</td><td>The port to which to bind. </td></tr>
    <tr><td class="paramname">opts</td><td>Optional additional flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

</div>
</div>
<a id="ade65abcde580bdf8458512966d16deb4" name="ade65abcde580bdf8458512966d16deb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade65abcde580bdf8458512966d16deb4">&#9670;&#160;</a></span>bind() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uvw::tcp_handle::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuvw_1_1socket__address.html">socket_address</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tcp_flags&#160;</td>
          <td class="paramname"><em>opts</em> = <code>tcp_flags::_UVW_ENUM</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds the handle to an address and port. </p>
<p>A successful call to this function does not guarantee that the call to <code><a class="el" href="classuvw_1_1stream__handle.html#ae1022648bbcdd62fa84a411aa80c1057" title="Starts listening for incoming connections.">listen()</a></code> or <code><a class="el" href="classuvw_1_1tcp__handle.html#a36226129a77639858cc152080c00442a" title="Establishes an IPv4 or IPv6 TCP connection.">connect()</a></code> will work properly.</p>
<p>Available flags are:</p>
<ul>
<li><code>tcp_handle::tcp_flags::IPV6ONLY</code>: it disables dual-stack support and only IPv6 is used.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A valid instance of <a class="el" href="structuvw_1_1socket__address.html" title="Address representation.">socket_address</a>. </td></tr>
    <tr><td class="paramname">opts</td><td>Optional additional flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

</div>
</div>
<a id="a5737d2d58f61d266be2e8fb7d3057838" name="a5737d2d58f61d266be2e8fb7d3057838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5737d2d58f61d266be2e8fb7d3057838">&#9670;&#160;</a></span>close_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uvw::tcp_handle::close_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets a TCP connection by sending a RST packet. </p>
<p>This is accomplished by setting the <code>SO_LINGER</code> socket option with a linger interval of zero and then calling <code>close</code>.<br  />
 Due to some platform inconsistencies, mixing of <code>shutdown</code> and <code>close_reset</code> calls is not allowed.</p>
<p>A close event is emitted when the connection has been reset.</p>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

</div>
</div>
<a id="a36226129a77639858cc152080c00442a" name="a36226129a77639858cc152080c00442a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36226129a77639858cc152080c00442a">&#9670;&#160;</a></span>connect() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uvw::tcp_handle::connect </td>
          <td>(</td>
          <td class="paramtype">const sockaddr &amp;&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes an IPv4 or IPv6 TCP connection. </p>
<p>On Windows if the addr is initialized to point to an unspecified address (<code>0.0.0.0</code> or <code>::</code>) it will be changed to point to localhost. This is done to match the behavior of Linux systems.</p>
<p>A connect event is emitted when the connection has been established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Initialized <code>sockaddr_in</code> or <code>sockaddr_in6</code> data structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

</div>
</div>
<a id="af1ce16492f9094bc80514b5852de2f97" name="af1ce16492f9094bc80514b5852de2f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ce16492f9094bc80514b5852de2f97">&#9670;&#160;</a></span>connect() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uvw::tcp_handle::connect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes an IPv4 or IPv6 TCP connection. </p>
<p>A connect event is emitted when the connection has been established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>The address to which to bind. </td></tr>
    <tr><td class="paramname">port</td><td>The port to which to bind. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

</div>
</div>
<a id="a0f458a7a7883768e6514e24fcd6c1077" name="a0f458a7a7883768e6514e24fcd6c1077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f458a7a7883768e6514e24fcd6c1077">&#9670;&#160;</a></span>connect() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uvw::tcp_handle::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuvw_1_1socket__address.html">socket_address</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes an IPv4 or IPv6 TCP connection. </p>
<p>A connect event is emitted when the connection has been established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A valid instance of <a class="el" href="structuvw_1_1socket__address.html" title="Address representation.">socket_address</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

</div>
</div>
<a id="a0cb5490996adb8ae112927a036aee85d" name="a0cb5490996adb8ae112927a036aee85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb5490996adb8ae112927a036aee85d">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int uvw::tcp_handle::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the handle. No socket is created as of yet. </p>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p>Reimplemented from <a class="el" href="structuvw_1_1uv__type.html#ae97ffacc0b381610d8d18a62a957a69c">uvw::uv_type&lt; U &gt;</a>.</p>

</div>
</div>
<a id="a03b637f533caff624152860f403a3ce2" name="a03b637f533caff624152860f403a3ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b637f533caff624152860f403a3ce2">&#9670;&#160;</a></span>keep_alive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::tcp_handle::keep_alive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time&#160;</td>
          <td class="paramname"><em>val</em> = <code>time{0}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables/Disables TCP keep-alive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable it, false otherwise. </td></tr>
    <tr><td class="paramname">val</td><td>Initial delay in seconds (use <code>std::chrono::duration&lt;unsigned int&gt;</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

</div>
</div>
<a id="ab6c83d92ee6ace5631592b361b14cfc0" name="ab6c83d92ee6ace5631592b361b14cfc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c83d92ee6ace5631592b361b14cfc0">&#9670;&#160;</a></span>no_delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::tcp_handle::no_delay </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables/Disables Nagleâ€™s algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>True to enable it, false otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

</div>
</div>
<a id="a6471fd78e04097d697f377a09f21b074" name="a6471fd78e04097d697f377a09f21b074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6471fd78e04097d697f377a09f21b074">&#9670;&#160;</a></span>open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uvw::tcp_handle::open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceuvw.html#aa64a7948231fbdec46df43be0c24f806">os_socket_handle</a>&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an existing file descriptor or SOCKET as a TCP handle. </p>
<p>The passed file descriptor or SOCKET is not checked for its type, but itâ€™s required that it represents a valid stream socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>A valid socket handle (either a file descriptor or a SOCKET).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

</div>
</div>
<a id="ac02b6d53c63af19d7a972c4b9d950e17" name="ac02b6d53c63af19d7a972c4b9d950e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02b6d53c63af19d7a972c4b9d950e17">&#9670;&#160;</a></span>peer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structuvw_1_1socket__address.html">socket_address</a> uvw::tcp_handle::peer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the address of the peer connected to the handle. </p>
<dl class="section return"><dt>Returns</dt><dd>A valid instance of <a class="el" href="structuvw_1_1socket__address.html" title="Address representation.">socket_address</a>, an empty one in case of errors. </dd></dl>

</div>
</div>
<a id="a99480e7a5d3ece02605268da008ecb4d" name="a99480e7a5d3ece02605268da008ecb4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99480e7a5d3ece02605268da008ecb4d">&#9670;&#160;</a></span>simultaneous_accepts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::tcp_handle::simultaneous_accepts </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables/Disables simultaneous asynchronous accept requests. </p>
<p>Enables/Disables simultaneous asynchronous accept requests that are queued by the operating system when listening for new TCP connections.<br  />
 This setting is used to tune a TCP server for the desired performance. Having simultaneous accepts can significantly improve the rate of accepting connections (which is why it is enabled by default) but may lead to uneven load distribution in multi-process setups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable it, false otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

</div>
</div>
<a id="ad9dc0685013fc8fb3e1c9effabdda4d2" name="ad9dc0685013fc8fb3e1c9effabdda4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9dc0685013fc8fb3e1c9effabdda4d2">&#9670;&#160;</a></span>sock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structuvw_1_1socket__address.html">socket_address</a> uvw::tcp_handle::sock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current address to which the handle is bound. </p>
<dl class="section return"><dt>Returns</dt><dd>A valid instance of <a class="el" href="structuvw_1_1socket__address.html" title="Address representation.">socket_address</a>, an empty one in case of errors. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/uvw/<a class="el" href="tcp_8h_source.html">tcp.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
