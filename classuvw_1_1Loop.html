<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uvw: uvw::loop Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">uvw<span id="projectnumber">&#160;3.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceuvw.html">uvw</a></li><li class="navelem"><a class="el" href="classuvw_1_1loop.html">loop</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classuvw_1_1loop-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">uvw::loop Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>The loop class.  
 <a href="classuvw_1_1loop.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="loop_8h_source.html">loop.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for uvw::loop:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1loop__inherit__graph.png" border="0" usemap="#auvw_1_1loop_inherit__map" alt="Inheritance graph"/></div>
<map name="auvw_1_1loop_inherit__map" id="auvw_1_1loop_inherit__map">
<area shape="rect" title="The loop class." alt="" coords="37,79,112,104"/>
<area shape="rect" href="classuvw_1_1emitter.html" title=" " alt="" coords="5,5,144,31"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for uvw::loop:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1loop__coll__graph.png" border="0" usemap="#auvw_1_1loop_coll__map" alt="Collaboration graph"/></div>
<map name="auvw_1_1loop_coll__map" id="auvw_1_1loop_coll__map">
<area shape="rect" title="The loop class." alt="" coords="37,79,112,104"/>
<area shape="rect" href="classuvw_1_1emitter.html" title=" " alt="" coords="5,5,144,31"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acb38eaee2680ed1c4ba74459e5c2a84a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acb38eaee2680ed1c4ba74459e5c2a84a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#acb38eaee2680ed1c4ba74459e5c2a84a">configure</a> (option flag, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:acb38eaee2680ed1c4ba74459e5c2a84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets additional loop options.  <br /></td></tr>
<tr class="separator:acb38eaee2680ed1c4ba74459e5c2a84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e1eb17d55ab7b8d089e55823015618"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a36e1eb17d55ab7b8d089e55823015618"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#a36e1eb17d55ab7b8d089e55823015618">resource</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a36e1eb17d55ab7b8d089e55823015618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates resources of any type.  <br /></td></tr>
<tr class="separator:a36e1eb17d55ab7b8d089e55823015618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0dbe4d1e82e43a8df3df1c7386efca"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:aef0dbe4d1e82e43a8df3df1c7386efca"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#aef0dbe4d1e82e43a8df3df1c7386efca">uninitialized_resource</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:aef0dbe4d1e82e43a8df3df1c7386efca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates uninitialized resources of any type.  <br /></td></tr>
<tr class="separator:aef0dbe4d1e82e43a8df3df1c7386efca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a8719f173a417a722fe779792a52e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#ac0a8719f173a417a722fe779792a52e6">close</a> ()</td></tr>
<tr class="memdesc:ac0a8719f173a417a722fe779792a52e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases all internal loop resources.  <br /></td></tr>
<tr class="separator:ac0a8719f173a417a722fe779792a52e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199e23bce642f5618e3d0c2b1e8d0cdf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#a199e23bce642f5618e3d0c2b1e8d0cdf">run</a> (run_mode mode=run_mode::DEFAULT) noexcept</td></tr>
<tr class="memdesc:a199e23bce642f5618e3d0c2b1e8d0cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the event loop.  <br /></td></tr>
<tr class="separator:a199e23bce642f5618e3d0c2b1e8d0cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d56b835e022e812d4930367b0a4f210"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#a5d56b835e022e812d4930367b0a4f210">alive</a> () const noexcept</td></tr>
<tr class="memdesc:a5d56b835e022e812d4930367b0a4f210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are active resources.  <br /></td></tr>
<tr class="separator:a5d56b835e022e812d4930367b0a4f210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafbdbc9022bf12d4aad3db16dcee442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#aaafbdbc9022bf12d4aad3db16dcee442">stop</a> () noexcept</td></tr>
<tr class="memdesc:aaafbdbc9022bf12d4aad3db16dcee442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the event loop.  <br /></td></tr>
<tr class="separator:aaafbdbc9022bf12d4aad3db16dcee442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbc84b4d00e0e61cf68bff4b7560b1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#addbc84b4d00e0e61cf68bff4b7560b1f">descriptor</a> () const noexcept</td></tr>
<tr class="memdesc:addbc84b4d00e0e61cf68bff4b7560b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get backend file descriptor.  <br /></td></tr>
<tr class="separator:addbc84b4d00e0e61cf68bff4b7560b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa358c1daf70696679edd08513e1f3e31"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, time &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#aa358c1daf70696679edd08513e1f3e31">timeout</a> () const noexcept</td></tr>
<tr class="memdesc:aa358c1daf70696679edd08513e1f3e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the poll timeout.  <br /></td></tr>
<tr class="separator:aa358c1daf70696679edd08513e1f3e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae404d30c956b2c5fa15ec3997f47fc"><td class="memItemLeft" align="right" valign="top">time&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#aeae404d30c956b2c5fa15ec3997f47fc">idle_time</a> () const noexcept</td></tr>
<tr class="memdesc:aeae404d30c956b2c5fa15ec3997f47fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of time the event loop has been idle. The call is thread safe.  <br /></td></tr>
<tr class="separator:aeae404d30c956b2c5fa15ec3997f47fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48abde5d862db1a856900b08ecc02dd"><td class="memItemLeft" align="right" valign="top">time&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#ab48abde5d862db1a856900b08ecc02dd">now</a> () const noexcept</td></tr>
<tr class="memdesc:ab48abde5d862db1a856900b08ecc02dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current timestamp in milliseconds.  <br /></td></tr>
<tr class="separator:ab48abde5d862db1a856900b08ecc02dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762ed24cc491eef2c942505d1885b0aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#a762ed24cc491eef2c942505d1885b0aa">update</a> () const noexcept</td></tr>
<tr class="memdesc:a762ed24cc491eef2c942505d1885b0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the event loop’s concept of <em>now</em>.  <br /></td></tr>
<tr class="separator:a762ed24cc491eef2c942505d1885b0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46a050e186935c0be4eca7815cd9207"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:aa46a050e186935c0be4eca7815cd9207"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#aa46a050e186935c0be4eca7815cd9207">walk</a> (Func callback)</td></tr>
<tr class="memdesc:aa46a050e186935c0be4eca7815cd9207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walks the list of handles.  <br /></td></tr>
<tr class="separator:aa46a050e186935c0be4eca7815cd9207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a569b877ff0c1cd3f66e21d5a2ded4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#a2a569b877ff0c1cd3f66e21d5a2ded4c">fork</a> () noexcept</td></tr>
<tr class="memdesc:a2a569b877ff0c1cd3f66e21d5a2ded4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize any kernel state necessary in the child process after a fork(2) system call.  <br /></td></tr>
<tr class="separator:a2a569b877ff0c1cd3f66e21d5a2ded4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1266e74e2a0edf9493394af3847bb3"><td class="memTemplParams" colspan="2">template&lt;typename R  = void&gt; </td></tr>
<tr class="memitem:a1b1266e74e2a0edf9493394af3847bb3"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#a1b1266e74e2a0edf9493394af3847bb3">data</a> () const</td></tr>
<tr class="memdesc:a1b1266e74e2a0edf9493394af3847bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets user-defined data. <code>uvw</code> won't use this field in any case.  <br /></td></tr>
<tr class="separator:a1b1266e74e2a0edf9493394af3847bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5f858b0de8daf348f89af2997063c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#a7b5f858b0de8daf348f89af2997063c7">data</a> (std::shared_ptr&lt; void &gt; ud)</td></tr>
<tr class="memdesc:a7b5f858b0de8daf348f89af2997063c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets arbitrary data. <code>uvw</code> won't use this field in any case.  <br /></td></tr>
<tr class="separator:a7b5f858b0de8daf348f89af2997063c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1f127cadc84b1729bc7835b697d3bf"><td class="memItemLeft" align="right" valign="top">const uv_loop_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#a4e1f127cadc84b1729bc7835b697d3bf">raw</a> () const noexcept</td></tr>
<tr class="memdesc:a4e1f127cadc84b1729bc7835b697d3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <br /></td></tr>
<tr class="separator:a4e1f127cadc84b1729bc7835b697d3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be924a8e240c444c69fe7c4e754892f"><td class="memItemLeft" align="right" valign="top">uv_loop_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#a8be924a8e240c444c69fe7c4e754892f">raw</a> () noexcept</td></tr>
<tr class="memdesc:a8be924a8e240c444c69fe7c4e754892f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <br /></td></tr>
<tr class="separator:a8be924a8e240c444c69fe7c4e754892f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1emitter"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1emitter')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1emitter.html">uvw::emitter&lt; loop &gt;</a></td></tr>
<tr class="memitem:ab913fa1c005a33c73b2eb2b0d1051b1f inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1emitter.html#ab913fa1c005a33c73b2eb2b0d1051b1f">on</a> (listener_t&lt; U &gt; f)</td></tr>
<tr class="memdesc:ab913fa1c005a33c73b2eb2b0d1051b1f inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a long-lived listener with the event emitter.  <br /></td></tr>
<tr class="separator:ab913fa1c005a33c73b2eb2b0d1051b1f inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accff5c096692f5eebbe941189644e69d inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top"><a id="accff5c096692f5eebbe941189644e69d" name="accff5c096692f5eebbe941189644e69d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> () noexcept</td></tr>
<tr class="memdesc:accff5c096692f5eebbe941189644e69d inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects the listener for the given event type. <br /></td></tr>
<tr class="separator:accff5c096692f5eebbe941189644e69d inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71435e74e775cfa7012fe2e52ca5193 inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top"><a id="aa71435e74e775cfa7012fe2e52ca5193" name="aa71435e74e775cfa7012fe2e52ca5193"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> () noexcept</td></tr>
<tr class="memdesc:aa71435e74e775cfa7012fe2e52ca5193 inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects all listeners. <br /></td></tr>
<tr class="separator:aa71435e74e775cfa7012fe2e52ca5193 inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02a29fe156faba7571b50450fc4f780 inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1emitter.html#ac02a29fe156faba7571b50450fc4f780">has</a> () const noexcept</td></tr>
<tr class="memdesc:ac02a29fe156faba7571b50450fc4f780 inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is a listener registered for the specific event.  <br /></td></tr>
<tr class="separator:ac02a29fe156faba7571b50450fc4f780 inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a77a8922defbd7643a4b18550d263a8d6"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classuvw_1_1loop.html">loop</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#a77a8922defbd7643a4b18550d263a8d6">create</a> ()</td></tr>
<tr class="memdesc:a77a8922defbd7643a4b18550d263a8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new loop instance.  <br /></td></tr>
<tr class="separator:a77a8922defbd7643a4b18550d263a8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d9897ff0dbc9a534bf38731fa16b46"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classuvw_1_1loop.html">loop</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#ad4d9897ff0dbc9a534bf38731fa16b46">create</a> (uv_loop_t *res)</td></tr>
<tr class="memdesc:ad4d9897ff0dbc9a534bf38731fa16b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new loop instance from an existing resource.  <br /></td></tr>
<tr class="separator:ad4d9897ff0dbc9a534bf38731fa16b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6392ce48b55f9b5644eeec2d6ce0e6d4"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classuvw_1_1loop.html">loop</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1loop.html#a6392ce48b55f9b5644eeec2d6ce0e6d4">get_default</a> ()</td></tr>
<tr class="memdesc:a6392ce48b55f9b5644eeec2d6ce0e6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the initialized default loop.  <br /></td></tr>
<tr class="separator:a6392ce48b55f9b5644eeec2d6ce0e6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The loop class. </p>
<p>The event loop is the central part of <code>uvw</code>'s functionalities, as well as <code>libuv</code>'s ones.<br  />
 It takes care of polling for I/O and scheduling callbacks to be run based on different sources of events. </p>

<p class="definition">Definition at line <a class="el" href="loop_8h_source.html#l00058">58</a> of file <a class="el" href="loop_8h_source.html">loop.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a5d56b835e022e812d4930367b0a4f210" name="a5d56b835e022e812d4930367b0a4f210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d56b835e022e812d4930367b0a4f210">&#9670;&#160;</a></span>alive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool uvw::loop::alive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if there are active resources. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there are active resources in the loop. </dd></dl>

</div>
</div>
<a id="ac0a8719f173a417a722fe779792a52e6" name="ac0a8719f173a417a722fe779792a52e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a8719f173a417a722fe779792a52e6">&#9670;&#160;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uvw::loop::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases all internal loop resources. </p>
<p>Call this function only when the loop has finished executing and all open handles and requests have been closed, or the loop will error.</p>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

</div>
</div>
<a id="acb38eaee2680ed1c4ba74459e5c2a84a" name="acb38eaee2680ed1c4ba74459e5c2a84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb38eaee2680ed1c4ba74459e5c2a84a">&#9670;&#160;</a></span>configure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int uvw::loop::configure </td>
          <td>(</td>
          <td class="paramtype">option&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets additional loop options. </p>
<p>You should normally call this before the first call to uv_run() unless mentioned otherwise.<br  />
 Supported options:</p>
<ul>
<li><code>loop::option::BLOCK_SIGNAL</code>: Block a signal when polling for new events. A second argument is required and it is the signal number.</li>
<li><code>loop::option::IDLE_TIME</code>: Accumulate the amount of idle time the event loop spends in the event provider. This option is necessary to use <code><a class="el" href="classuvw_1_1loop.html#aeae404d30c956b2c5fa15ec3997f47fc" title="Returns the amount of time the event loop has been idle. The call is thread safe.">idle_time()</a></code>.</li>
</ul>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/loop.html#c.uv_loop_configure">documentation</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="loop_8h_source.html#l00137">137</a> of file <a class="el" href="loop_8h_source.html">loop.h</a>.</p>

</div>
</div>
<a id="a77a8922defbd7643a4b18550d263a8d6" name="a77a8922defbd7643a4b18550d263a8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a8922defbd7643a4b18550d263a8d6">&#9670;&#160;</a></span>create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt; <a class="el" href="classuvw_1_1loop.html">loop</a> &gt; uvw::loop::create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new loop instance. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created loop. </dd></dl>

</div>
</div>
<a id="ad4d9897ff0dbc9a534bf38731fa16b46" name="ad4d9897ff0dbc9a534bf38731fa16b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d9897ff0dbc9a534bf38731fa16b46">&#9670;&#160;</a></span>create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt; <a class="el" href="classuvw_1_1loop.html">loop</a> &gt; uvw::loop::create </td>
          <td>(</td>
          <td class="paramtype">uv_loop_t *&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a new loop instance from an existing resource. </p>
<p>The lifetime of the resource must exceed that of the instance to which it's associated. Management of the memory associated with the resource is in charge of the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A valid pointer to a correctly initialized resource. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created loop. </dd></dl>

</div>
</div>
<a id="a1b1266e74e2a0edf9493394af3847bb3" name="a1b1266e74e2a0edf9493394af3847bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1266e74e2a0edf9493394af3847bb3">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; R &gt; uvw::loop::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets user-defined data. <code>uvw</code> won't use this field in any case. </p>
<dl class="section return"><dt>Returns</dt><dd>User-defined data if any, an invalid pointer otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="loop_8h_source.html#l00367">367</a> of file <a class="el" href="loop_8h_source.html">loop.h</a>.</p>

</div>
</div>
<a id="a7b5f858b0de8daf348f89af2997063c7" name="a7b5f858b0de8daf348f89af2997063c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5f858b0de8daf348f89af2997063c7">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::loop::data </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; void &gt;&#160;</td>
          <td class="paramname"><em>ud</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets arbitrary data. <code>uvw</code> won't use this field in any case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ud</td><td>User-defined arbitrary data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addbc84b4d00e0e61cf68bff4b7560b1f" name="addbc84b4d00e0e61cf68bff4b7560b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbc84b4d00e0e61cf68bff4b7560b1f">&#9670;&#160;</a></span>descriptor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int uvw::loop::descriptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get backend file descriptor. </p>
<p>Only kqueue, epoll and event ports are supported.<br  />
 This can be used in conjunction with <code>run(loop::run_mode::NOWAIT)</code> to poll in one thread and run the event loop’s callbacks in another.</p>
<dl class="section return"><dt>Returns</dt><dd>The backend file descriptor. </dd></dl>

</div>
</div>
<a id="a2a569b877ff0c1cd3f66e21d5a2ded4c" name="a2a569b877ff0c1cd3f66e21d5a2ded4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a569b877ff0c1cd3f66e21d5a2ded4c">&#9670;&#160;</a></span>fork()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int uvw::loop::fork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinitialize any kernel state necessary in the child process after a fork(2) system call. </p>
<p>Previously started watchers will continue to be started in the child process.</p>
<p>It is necessary to explicitly call this function on every event loop created in the parent process that you plan to continue to use in the child, including the default loop (even if you don’t continue to use it in the parent). This function must be called before calling any API function using the loop in the child. Failure to do so will result in undefined behaviour, possibly including duplicate events delivered to both parent and child or aborting the child process.</p>
<p>When possible, it is preferred to create a new loop in the child process instead of reusing a loop created in the parent. New loops created in the child process after the fork should not use this function.</p>
<p>Note that this function is not implemented on Windows.<br  />
 Note also that this function is experimental in <code>libuv</code>. It may contain bugs, and is subject to change or removal. API and ABI stability is not guaranteed.</p>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/loop.html#c.uv_loop_fork">documentation</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

</div>
</div>
<a id="a6392ce48b55f9b5644eeec2d6ce0e6d4" name="a6392ce48b55f9b5644eeec2d6ce0e6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6392ce48b55f9b5644eeec2d6ce0e6d4">&#9670;&#160;</a></span>get_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt; <a class="el" href="classuvw_1_1loop.html">loop</a> &gt; uvw::loop::get_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the initialized default loop. </p>
<p>It may return an empty pointer in case of failure.<br  />
 This function is just a convenient way for having a global loop throughout an application, the default loop is in no way different than the ones initialized with <code><a class="el" href="classuvw_1_1loop.html#a77a8922defbd7643a4b18550d263a8d6" title="Initializes a new loop instance.">create()</a></code>.<br  />
 As such, the default loop can be closed with <code><a class="el" href="classuvw_1_1loop.html#ac0a8719f173a417a722fe779792a52e6" title="Releases all internal loop resources.">close()</a></code> so the resources associated with it are freed (even if it is not strictly necessary).</p>
<dl class="section return"><dt>Returns</dt><dd>The initialized default loop. </dd></dl>

</div>
</div>
<a id="aeae404d30c956b2c5fa15ec3997f47fc" name="aeae404d30c956b2c5fa15ec3997f47fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae404d30c956b2c5fa15ec3997f47fc">&#9670;&#160;</a></span>idle_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">time uvw::loop::idle_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the amount of time the event loop has been idle. The call is thread safe. </p>
<dl class="section return"><dt>Returns</dt><dd>The accumulated time spent idle. </dd></dl>

</div>
</div>
<a id="ab48abde5d862db1a856900b08ecc02dd" name="ab48abde5d862db1a856900b08ecc02dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48abde5d862db1a856900b08ecc02dd">&#9670;&#160;</a></span>now()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">time uvw::loop::now </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current timestamp in milliseconds. </p>
<p>The timestamp is cached at the start of the event loop tick.<br  />
 The timestamp increases monotonically from some arbitrary point in time.<br  />
 Don’t make assumptions about the starting point, you will only get disappointed.</p>
<dl class="section return"><dt>Returns</dt><dd>The current timestamp in milliseconds (actual type is <code>std::chrono::duration&lt;uint64_t, std::milli&gt;</code>). </dd></dl>

</div>
</div>
<a id="a4e1f127cadc84b1729bc7835b697d3bf" name="a4e1f127cadc84b1729bc7835b697d3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1f127cadc84b1729bc7835b697d3bf">&#9670;&#160;</a></span>raw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uv_loop_t * uvw::loop::raw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the underlying raw data structure. </p>
<p>This function should not be used, unless you know exactly what you are doing and what are the risks.<br  />
 Going raw is dangerous, mainly because the lifetime management of a loop, a handle or a request is in charge to the library itself and users should not work around it.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use this function at your own risk, but do not expect any support in case of bugs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The underlying raw data structure. </dd></dl>

</div>
</div>
<a id="a8be924a8e240c444c69fe7c4e754892f" name="a8be924a8e240c444c69fe7c4e754892f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be924a8e240c444c69fe7c4e754892f">&#9670;&#160;</a></span>raw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uv_loop_t * uvw::loop::raw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the underlying raw data structure. </p>
<p>This function should not be used, unless you know exactly what you are doing and what are the risks.<br  />
 Going raw is dangerous, mainly because the lifetime management of a loop, a handle or a request is in charge to the library itself and users should not work around it.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use this function at your own risk, but do not expect any support in case of bugs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The underlying raw data structure. </dd></dl>

</div>
</div>
<a id="a36e1eb17d55ab7b8d089e55823015618" name="a36e1eb17d55ab7b8d089e55823015618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e1eb17d55ab7b8d089e55823015618">&#9670;&#160;</a></span>resource()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; R &gt; uvw::loop::resource </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates resources of any type. </p>
<p>This should be used as a default method to create resources.<br  />
 The arguments are the ones required for the specific resource.</p>
<p>Use it as <code>loop-&gt;resource&lt;<a class="el" href="classuvw_1_1timer__handle.html" title="The timer handle.">uvw::timer_handle</a>&gt;()</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created resource. </dd></dl>

<p class="definition">Definition at line <a class="el" href="loop_8h_source.html#l00152">152</a> of file <a class="el" href="loop_8h_source.html">loop.h</a>.</p>

</div>
</div>
<a id="a199e23bce642f5618e3d0c2b1e8d0cdf" name="a199e23bce642f5618e3d0c2b1e8d0cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199e23bce642f5618e3d0c2b1e8d0cdf">&#9670;&#160;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int uvw::loop::run </td>
          <td>(</td>
          <td class="paramtype">run_mode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>run_mode::DEFAULT</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs the event loop. </p>
<p>Available modes are:</p>
<ul>
<li><code>loop::run_mode::DEFAULT</code>: Runs the event loop until there are no more active and referenced handles or requests.</li>
<li><code>loop::run_mode::ONCE</code>: Poll for i/o once. Note that this function blocks if there are no pending callbacks.</li>
<li><code>loop::run_mode::NOWAIT</code>: Poll for i/o once but don’t block if there are no pending callbacks.</li>
</ul>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/loop.html#c.uv_run">documentation</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

</div>
</div>
<a id="aaafbdbc9022bf12d4aad3db16dcee442" name="aaafbdbc9022bf12d4aad3db16dcee442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafbdbc9022bf12d4aad3db16dcee442">&#9670;&#160;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::loop::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops the event loop. </p>
<p>It causes <code><a class="el" href="classuvw_1_1loop.html#a199e23bce642f5618e3d0c2b1e8d0cdf" title="Runs the event loop.">run()</a></code> to end as soon as possible.<br  />
 This will happen not sooner than the next loop iteration.<br  />
 If this function was called before blocking for I/O, the loop won’t block for I/O on this iteration. </p>

</div>
</div>
<a id="aa358c1daf70696679edd08513e1f3e31" name="aa358c1daf70696679edd08513e1f3e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa358c1daf70696679edd08513e1f3e31">&#9670;&#160;</a></span>timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, time &gt; uvw::loop::timeout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the poll timeout. </p>
<dl class="section return"><dt>Returns</dt><dd>A <code>std::pair</code> composed as it follows:<ul>
<li>A boolean value that is true in case of valid timeout, false otherwise.</li>
<li>Milliseconds (<code>std::chrono::duration&lt;uint64_t, std::milli&gt;</code>). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aef0dbe4d1e82e43a8df3df1c7386efca" name="aef0dbe4d1e82e43a8df3df1c7386efca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0dbe4d1e82e43a8df3df1c7386efca">&#9670;&#160;</a></span>uninitialized_resource()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; R &gt; uvw::loop::uninitialized_resource </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates uninitialized resources of any type. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created resource. </dd></dl>

<p class="definition">Definition at line <a class="el" href="loop_8h_source.html#l00163">163</a> of file <a class="el" href="loop_8h_source.html">loop.h</a>.</p>

</div>
</div>
<a id="a762ed24cc491eef2c942505d1885b0aa" name="a762ed24cc491eef2c942505d1885b0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762ed24cc491eef2c942505d1885b0aa">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::loop::update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the event loop’s concept of <em>now</em>. </p>
<p>The current time is cached at the start of the event loop tick in order to reduce the number of time-related system calls.<br  />
 You won’t normally need to call this function unless you have callbacks that block the event loop for longer periods of time, where <em>longer</em> is somewhat subjective but probably on the order of a millisecond or more. </p>

</div>
</div>
<a id="aa46a050e186935c0be4eca7815cd9207" name="aa46a050e186935c0be4eca7815cd9207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46a050e186935c0be4eca7815cd9207">&#9670;&#160;</a></span>walk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void uvw::loop::walk </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walks the list of handles. </p>
<p>The callback is invoked once for each handle that is still active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>A function to invoke once for each active handle. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loop_8h_source.html#l00272">272</a> of file <a class="el" href="loop_8h_source.html">loop.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/uvw/<a class="el" href="loop_8h_source.html">loop.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
