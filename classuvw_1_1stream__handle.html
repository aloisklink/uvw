<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uvw: uvw::stream_handle&lt; T, U, E &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">uvw<span id="projectnumber">&#160;3.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceuvw.html">uvw</a></li><li class="navelem"><a class="el" href="classuvw_1_1stream__handle.html">stream_handle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classuvw_1_1stream__handle-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">uvw::stream_handle&lt; T, U, E &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The stream handle.  
 <a href="classuvw_1_1stream__handle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="stream_8h_source.html">stream.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for uvw::stream_handle&lt; T, U, E &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1stream__handle__inherit__graph.png" border="0" usemap="#auvw_1_1stream__handle_3_01T_00_01U_00_01E_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="auvw_1_1stream__handle_3_01T_00_01U_00_01E_01_4_inherit__map" id="auvw_1_1stream__handle_3_01T_00_01U_00_01E_01_4_inherit__map">
<area shape="rect" title="The stream handle." alt="" coords="613,27,749,67"/>
<area shape="rect" href="classuvw_1_1handle.html" title=" " alt="" coords="393,5,565,89"/>
<area shape="rect" href="classuvw_1_1resource.html" title=" " alt="" coords="204,27,345,67"/>
<area shape="rect" href="structuvw_1_1uv__type.html" title="Wrapper class for underlying types." alt="" coords="17,9,145,35"/>
<area shape="rect" href="classuvw_1_1emitter.html" title=" " alt="" coords="5,59,156,84"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for uvw::stream_handle&lt; T, U, E &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1stream__handle__coll__graph.png" border="0" usemap="#auvw_1_1stream__handle_3_01T_00_01U_00_01E_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="auvw_1_1stream__handle_3_01T_00_01U_00_01E_01_4_coll__map" id="auvw_1_1stream__handle_3_01T_00_01U_00_01E_01_4_coll__map">
<area shape="rect" title="The stream handle." alt="" coords="613,27,749,67"/>
<area shape="rect" href="classuvw_1_1handle.html" title=" " alt="" coords="393,5,565,89"/>
<area shape="rect" href="classuvw_1_1resource.html" title=" " alt="" coords="204,27,345,67"/>
<area shape="rect" href="structuvw_1_1uv__type.html" title="Wrapper class for underlying types." alt="" coords="17,9,145,35"/>
<area shape="rect" href="classuvw_1_1emitter.html" title=" " alt="" coords="5,59,156,84"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a74a48d00b23a4bd5a231d3f8bfaa655d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a74a48d00b23a4bd5a231d3f8bfaa655d">shutdown</a> ()</td></tr>
<tr class="memdesc:a74a48d00b23a4bd5a231d3f8bfaa655d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdowns the outgoing (write) side of a duplex stream.  <br /></td></tr>
<tr class="separator:a74a48d00b23a4bd5a231d3f8bfaa655d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1022648bbcdd62fa84a411aa80c1057"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#ae1022648bbcdd62fa84a411aa80c1057">listen</a> (int backlog=DEFAULT_BACKLOG)</td></tr>
<tr class="memdesc:ae1022648bbcdd62fa84a411aa80c1057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts listening for incoming connections.  <br /></td></tr>
<tr class="separator:ae1022648bbcdd62fa84a411aa80c1057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005a77de769d10b660c198478ae03dba"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a005a77de769d10b660c198478ae03dba"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a005a77de769d10b660c198478ae03dba">accept</a> (S &amp;ref)</td></tr>
<tr class="memdesc:a005a77de769d10b660c198478ae03dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accepts incoming connections.  <br /></td></tr>
<tr class="separator:a005a77de769d10b660c198478ae03dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb471cfc6eec1dc2683e381ec828087"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a1fb471cfc6eec1dc2683e381ec828087">read</a> ()</td></tr>
<tr class="memdesc:a1fb471cfc6eec1dc2683e381ec828087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts reading data from an incoming stream.  <br /></td></tr>
<tr class="separator:a1fb471cfc6eec1dc2683e381ec828087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06ccaed032ab19ac2466ba35c5d1c9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#ae06ccaed032ab19ac2466ba35c5d1c9e">stop</a> ()</td></tr>
<tr class="memdesc:ae06ccaed032ab19ac2466ba35c5d1c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops reading data from the stream.  <br /></td></tr>
<tr class="separator:ae06ccaed032ab19ac2466ba35c5d1c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a3ac704e013ede496a3d998a74ebc7"><td class="memTemplParams" colspan="2">template&lt;typename Deleter &gt; </td></tr>
<tr class="memitem:ad8a3ac704e013ede496a3d998a74ebc7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#ad8a3ac704e013ede496a3d998a74ebc7">write</a> (std::unique_ptr&lt; char[], Deleter &gt; <a class="el" href="classuvw_1_1resource.html#a7c05e988ebaa14d1dbbc781951dc3a88">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:ad8a3ac704e013ede496a3d998a74ebc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the stream.  <br /></td></tr>
<tr class="separator:ad8a3ac704e013ede496a3d998a74ebc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0895fadb7985f8b437ff3bce62a80b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#afd0895fadb7985f8b437ff3bce62a80b">write</a> (char *<a class="el" href="classuvw_1_1resource.html#a7c05e988ebaa14d1dbbc781951dc3a88">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:afd0895fadb7985f8b437ff3bce62a80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to the stream.  <br /></td></tr>
<tr class="separator:afd0895fadb7985f8b437ff3bce62a80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a943387b69c05b7bb6469f7042ca08"><td class="memTemplParams" colspan="2">template&lt;typename S , typename Deleter &gt; </td></tr>
<tr class="memitem:a28a943387b69c05b7bb6469f7042ca08"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a28a943387b69c05b7bb6469f7042ca08">write</a> (S &amp;send, std::unique_ptr&lt; char[], Deleter &gt; <a class="el" href="classuvw_1_1resource.html#a7c05e988ebaa14d1dbbc781951dc3a88">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:a28a943387b69c05b7bb6469f7042ca08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended write function for sending handles over a pipe handle.  <br /></td></tr>
<tr class="separator:a28a943387b69c05b7bb6469f7042ca08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace2532231266f660ad26876602eaad0"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:aace2532231266f660ad26876602eaad0"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#aace2532231266f660ad26876602eaad0">write</a> (S &amp;send, char *<a class="el" href="classuvw_1_1resource.html#a7c05e988ebaa14d1dbbc781951dc3a88">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:aace2532231266f660ad26876602eaad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended write function for sending handles over a pipe handle.  <br /></td></tr>
<tr class="separator:aace2532231266f660ad26876602eaad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07b07065609821932537dc23773b2ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#af07b07065609821932537dc23773b2ed">try_write</a> (std::unique_ptr&lt; char[]&gt; <a class="el" href="classuvw_1_1resource.html#a7c05e988ebaa14d1dbbc781951dc3a88">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:af07b07065609821932537dc23773b2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a write request if it can be completed immediately.  <br /></td></tr>
<tr class="separator:af07b07065609821932537dc23773b2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b12e5126cba8c84a3fdbb01cc3b81a"><td class="memTemplParams" colspan="2">template&lt;typename V , typename W &gt; </td></tr>
<tr class="memitem:aa0b12e5126cba8c84a3fdbb01cc3b81a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#aa0b12e5126cba8c84a3fdbb01cc3b81a">try_write</a> (std::unique_ptr&lt; char[]&gt; <a class="el" href="classuvw_1_1resource.html#a7c05e988ebaa14d1dbbc781951dc3a88">data</a>, unsigned int len, <a class="el" href="classuvw_1_1stream__handle.html">stream_handle</a>&lt; V, W &gt; &amp;send)</td></tr>
<tr class="memdesc:aa0b12e5126cba8c84a3fdbb01cc3b81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a write request if it can be completed immediately.  <br /></td></tr>
<tr class="separator:aa0b12e5126cba8c84a3fdbb01cc3b81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d56a5108fd6f3fd7f11f7e5507c7727"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a6d56a5108fd6f3fd7f11f7e5507c7727">try_write</a> (char *<a class="el" href="classuvw_1_1resource.html#a7c05e988ebaa14d1dbbc781951dc3a88">data</a>, unsigned int len)</td></tr>
<tr class="memdesc:a6d56a5108fd6f3fd7f11f7e5507c7727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a write request if it can be completed immediately.  <br /></td></tr>
<tr class="separator:a6d56a5108fd6f3fd7f11f7e5507c7727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729ff5d6b7da6af3c70068a3dfca5204"><td class="memTemplParams" colspan="2">template&lt;typename V , typename W &gt; </td></tr>
<tr class="memitem:a729ff5d6b7da6af3c70068a3dfca5204"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a729ff5d6b7da6af3c70068a3dfca5204">try_write</a> (char *<a class="el" href="classuvw_1_1resource.html#a7c05e988ebaa14d1dbbc781951dc3a88">data</a>, unsigned int len, <a class="el" href="classuvw_1_1stream__handle.html">stream_handle</a>&lt; V, W &gt; &amp;send)</td></tr>
<tr class="memdesc:a729ff5d6b7da6af3c70068a3dfca5204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a write request if it can be completed immediately.  <br /></td></tr>
<tr class="separator:a729ff5d6b7da6af3c70068a3dfca5204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459eccecaee81d4a8619e1a073e81a69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a459eccecaee81d4a8619e1a073e81a69">readable</a> () const noexcept</td></tr>
<tr class="memdesc:a459eccecaee81d4a8619e1a073e81a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream is readable.  <br /></td></tr>
<tr class="separator:a459eccecaee81d4a8619e1a073e81a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ac22ea79bf27479eedbda9ac1101f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a09ac22ea79bf27479eedbda9ac1101f0">writable</a> () const noexcept</td></tr>
<tr class="memdesc:a09ac22ea79bf27479eedbda9ac1101f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream is writable.  <br /></td></tr>
<tr class="separator:a09ac22ea79bf27479eedbda9ac1101f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824348c23445390d58fb393f731acdee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a824348c23445390d58fb393f731acdee">blocking</a> (bool enable=false)</td></tr>
<tr class="memdesc:a824348c23445390d58fb393f731acdee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables blocking mode for a stream.  <br /></td></tr>
<tr class="separator:a824348c23445390d58fb393f731acdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455c3e4cccd8f8119d1f251b809ea810"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1stream__handle.html#a455c3e4cccd8f8119d1f251b809ea810">write_queue_size</a> () const noexcept</td></tr>
<tr class="memdesc:a455c3e4cccd8f8119d1f251b809ea810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the amount of queued bytes waiting to be sent.  <br /></td></tr>
<tr class="separator:a455c3e4cccd8f8119d1f251b809ea810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1handle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1handle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1handle.html">uvw::handle&lt; T, U, listen_event, end_event, connect_event, shutdown_event, data_event, write_event, E... &gt;</a></td></tr>
<tr class="memitem:a80c5ba8c4db128cc525406e998549b96 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#a9e28e1855691dd1af105626ed11f3ac4">handle_category</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a80c5ba8c4db128cc525406e998549b96">category</a> () const noexcept</td></tr>
<tr class="memdesc:a80c5ba8c4db128cc525406e998549b96 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the category of the handle.  <br /></td></tr>
<tr class="separator:a80c5ba8c4db128cc525406e998549b96 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88018be1fa3105e958c50a9f1881baa9 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">handle_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a88018be1fa3105e958c50a9f1881baa9">type</a> () const noexcept</td></tr>
<tr class="memdesc:a88018be1fa3105e958c50a9f1881baa9 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the handle.  <br /></td></tr>
<tr class="separator:a88018be1fa3105e958c50a9f1881baa9 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938d3ac6e5cc78f9442f9bb851170643 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a938d3ac6e5cc78f9442f9bb851170643">active</a> () const noexcept</td></tr>
<tr class="memdesc:a938d3ac6e5cc78f9442f9bb851170643 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the handle is active.  <br /></td></tr>
<tr class="separator:a938d3ac6e5cc78f9442f9bb851170643 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93cbf2156f0d673093e48832104a3cc inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#ae93cbf2156f0d673093e48832104a3cc">closing</a> () const noexcept</td></tr>
<tr class="memdesc:ae93cbf2156f0d673093e48832104a3cc inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a handle is closing or closed.  <br /></td></tr>
<tr class="separator:ae93cbf2156f0d673093e48832104a3cc inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3648ed9805e8d0e8963f137f8584e483 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a3648ed9805e8d0e8963f137f8584e483">close</a> () noexcept</td></tr>
<tr class="memdesc:a3648ed9805e8d0e8963f137f8584e483 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request handle to be closed.  <br /></td></tr>
<tr class="separator:a3648ed9805e8d0e8963f137f8584e483 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0d788997368ab1af2dc475126a46d2 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a2f0d788997368ab1af2dc475126a46d2">reference</a> () noexcept</td></tr>
<tr class="memdesc:a2f0d788997368ab1af2dc475126a46d2 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference the given handle.  <br /></td></tr>
<tr class="separator:a2f0d788997368ab1af2dc475126a46d2 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a91d1353c19f1a05aace78dc2cc453 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a83a91d1353c19f1a05aace78dc2cc453">unreference</a> () noexcept</td></tr>
<tr class="memdesc:a83a91d1353c19f1a05aace78dc2cc453 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unreference the given handle.  <br /></td></tr>
<tr class="separator:a83a91d1353c19f1a05aace78dc2cc453 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1403f961ab40063f79c4a293c78ed63c inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a1403f961ab40063f79c4a293c78ed63c">referenced</a> () const noexcept</td></tr>
<tr class="memdesc:a1403f961ab40063f79c4a293c78ed63c inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given handle referenced.  <br /></td></tr>
<tr class="separator:a1403f961ab40063f79c4a293c78ed63c inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5852080ba1fd71a302c2424cf2df9a27 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a5852080ba1fd71a302c2424cf2df9a27">size</a> () const noexcept</td></tr>
<tr class="memdesc:a5852080ba1fd71a302c2424cf2df9a27 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the underlying handle type.  <br /></td></tr>
<tr class="separator:a5852080ba1fd71a302c2424cf2df9a27 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99406ca909aeaac17522959db8c71a4 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#aa99406ca909aeaac17522959db8c71a4">send_buffer_size</a> ()</td></tr>
<tr class="memdesc:aa99406ca909aeaac17522959db8c71a4 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the send buffer used for the socket.  <br /></td></tr>
<tr class="separator:aa99406ca909aeaac17522959db8c71a4 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917ab9c1f011232b50f9980f29167ee2 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a917ab9c1f011232b50f9980f29167ee2">send_buffer_size</a> (int value)</td></tr>
<tr class="memdesc:a917ab9c1f011232b50f9980f29167ee2 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the send buffer used for the socket.  <br /></td></tr>
<tr class="separator:a917ab9c1f011232b50f9980f29167ee2 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3337ef0c68ed5ba0e9bea0e2e90539 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a7a3337ef0c68ed5ba0e9bea0e2e90539">recv_buffer_size</a> ()</td></tr>
<tr class="memdesc:a7a3337ef0c68ed5ba0e9bea0e2e90539 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the receive buffer used for the socket.  <br /></td></tr>
<tr class="separator:a7a3337ef0c68ed5ba0e9bea0e2e90539 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace23bb725f6f80ae7a611f5228ad9f8d inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#ace23bb725f6f80ae7a611f5228ad9f8d">recv_buffer_size</a> (int value)</td></tr>
<tr class="memdesc:ace23bb725f6f80ae7a611f5228ad9f8d inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the receive buffer used for the socket.  <br /></td></tr>
<tr class="separator:ace23bb725f6f80ae7a611f5228ad9f8d inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce9568c94aa0122ff4cee6a57b4fae5 inherit pub_methods_classuvw_1_1handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#a1a4f79e341b89257a11403ee0739f2b4">os_file_descriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a0ce9568c94aa0122ff4cee6a57b4fae5">fd</a> () const</td></tr>
<tr class="memdesc:a0ce9568c94aa0122ff4cee6a57b4fae5 inherit pub_methods_classuvw_1_1handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the platform dependent file descriptor equivalent.  <br /></td></tr>
<tr class="separator:a0ce9568c94aa0122ff4cee6a57b4fae5 inherit pub_methods_classuvw_1_1handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1resource"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1resource')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1resource.html">uvw::resource&lt; T, U, close_event, E... &gt;</a></td></tr>
<tr class="memitem:a7c05e988ebaa14d1dbbc781951dc3a88 inherit pub_methods_classuvw_1_1resource"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1resource.html#a7c05e988ebaa14d1dbbc781951dc3a88">data</a> () const</td></tr>
<tr class="memdesc:a7c05e988ebaa14d1dbbc781951dc3a88 inherit pub_methods_classuvw_1_1resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets user-defined data. <code>uvw</code> won't use this field in any case.  <br /></td></tr>
<tr class="separator:a7c05e988ebaa14d1dbbc781951dc3a88 inherit pub_methods_classuvw_1_1resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759079eb405e5d2fda795d199d8efa80 inherit pub_methods_classuvw_1_1resource"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1resource.html#a759079eb405e5d2fda795d199d8efa80">data</a> (std::shared_ptr&lt; void &gt; udata)</td></tr>
<tr class="memdesc:a759079eb405e5d2fda795d199d8efa80 inherit pub_methods_classuvw_1_1resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets arbitrary data. <code>uvw</code> won't use this field in any case.  <br /></td></tr>
<tr class="separator:a759079eb405e5d2fda795d199d8efa80 inherit pub_methods_classuvw_1_1resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structuvw_1_1uv__type"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structuvw_1_1uv__type')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structuvw_1_1uv__type.html">uvw::uv_type&lt; U &gt;</a></td></tr>
<tr class="memitem:ae97ffacc0b381610d8d18a62a957a69c inherit pub_methods_structuvw_1_1uv__type"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1uv__type.html#ae97ffacc0b381610d8d18a62a957a69c">init</a> ()</td></tr>
<tr class="memdesc:ae97ffacc0b381610d8d18a62a957a69c inherit pub_methods_structuvw_1_1uv__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the handle.  <br /></td></tr>
<tr class="separator:ae97ffacc0b381610d8d18a62a957a69c inherit pub_methods_structuvw_1_1uv__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03b0ebbae151c6157c5ba6a24a39a7b inherit pub_methods_structuvw_1_1uv__type"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuvw_1_1loop.html">loop</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1uv__type.html#ae03b0ebbae151c6157c5ba6a24a39a7b">parent</a> () const noexcept</td></tr>
<tr class="memdesc:ae03b0ebbae151c6157c5ba6a24a39a7b inherit pub_methods_structuvw_1_1uv__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the loop from which the resource was originated.  <br /></td></tr>
<tr class="separator:ae03b0ebbae151c6157c5ba6a24a39a7b inherit pub_methods_structuvw_1_1uv__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a6cb7ebde27aa348e340b76e49c6ae inherit pub_methods_structuvw_1_1uv__type"><td class="memItemLeft" align="right" valign="top">const U *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1uv__type.html#a06a6cb7ebde27aa348e340b76e49c6ae">raw</a> () const noexcept</td></tr>
<tr class="memdesc:a06a6cb7ebde27aa348e340b76e49c6ae inherit pub_methods_structuvw_1_1uv__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <br /></td></tr>
<tr class="separator:a06a6cb7ebde27aa348e340b76e49c6ae inherit pub_methods_structuvw_1_1uv__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b6f395815f2e99302b5f09be23767c inherit pub_methods_structuvw_1_1uv__type"><td class="memItemLeft" align="right" valign="top">U *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1uv__type.html#af4b6f395815f2e99302b5f09be23767c">raw</a> () noexcept</td></tr>
<tr class="memdesc:af4b6f395815f2e99302b5f09be23767c inherit pub_methods_structuvw_1_1uv__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <br /></td></tr>
<tr class="separator:af4b6f395815f2e99302b5f09be23767c inherit pub_methods_structuvw_1_1uv__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1emitter"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1emitter')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1emitter.html">uvw::emitter&lt; T, E... &gt;</a></td></tr>
<tr class="memitem:ab913fa1c005a33c73b2eb2b0d1051b1f inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1emitter.html#ab913fa1c005a33c73b2eb2b0d1051b1f">on</a> (listener_t&lt; U &gt; f)</td></tr>
<tr class="memdesc:ab913fa1c005a33c73b2eb2b0d1051b1f inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a long-lived listener with the event emitter.  <br /></td></tr>
<tr class="separator:ab913fa1c005a33c73b2eb2b0d1051b1f inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accff5c096692f5eebbe941189644e69d inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top"><a id="accff5c096692f5eebbe941189644e69d" name="accff5c096692f5eebbe941189644e69d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> () noexcept</td></tr>
<tr class="memdesc:accff5c096692f5eebbe941189644e69d inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects the listener for the given event type. <br /></td></tr>
<tr class="separator:accff5c096692f5eebbe941189644e69d inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71435e74e775cfa7012fe2e52ca5193 inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top"><a id="aa71435e74e775cfa7012fe2e52ca5193" name="aa71435e74e775cfa7012fe2e52ca5193"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> () noexcept</td></tr>
<tr class="memdesc:aa71435e74e775cfa7012fe2e52ca5193 inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects all listeners. <br /></td></tr>
<tr class="separator:aa71435e74e775cfa7012fe2e52ca5193 inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02a29fe156faba7571b50450fc4f780 inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1emitter.html#ac02a29fe156faba7571b50450fc4f780">has</a> () const noexcept</td></tr>
<tr class="memdesc:ac02a29fe156faba7571b50450fc4f780 inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is a listener registered for the specific event.  <br /></td></tr>
<tr class="separator:ac02a29fe156faba7571b50450fc4f780 inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename U, typename... E&gt;<br />
class uvw::stream_handle&lt; T, U, E &gt;</div><p>The stream handle. </p>
<p>Stream handles provide an abstraction of a duplex communication channel. The stream handle is an intermediate type, <code>uvw</code> provides three stream implementations: tcp, pipe and tty handles. </p>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00108">108</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a005a77de769d10b660c198478ae03dba" name="a005a77de769d10b660c198478ae03dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005a77de769d10b660c198478ae03dba">&#9670;&#160;</a></span>accept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::accept </td>
          <td>(</td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accepts incoming connections. </p>
<p>This call is used in conjunction with <code><a class="el" href="classuvw_1_1stream__handle.html#ae1022648bbcdd62fa84a411aa80c1057" title="Starts listening for incoming connections.">listen()</a></code> to accept incoming connections. Call this function after receiving a listen event to accept the connection. Before calling this function, the submitted handle must be initialized.</p>
<p>When the listen event is emitted it is guaranteed that this function will complete successfully the first time. If you attempt to use it more than once, it may fail.<br  />
 It is suggested to only call this function once per listen event.</p>
<dl class="section note"><dt>Note</dt><dd>Both the handles must be running on the same loop.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>An initialized handle to be used to accept the connection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00217">217</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a824348c23445390d58fb393f731acdee" name="a824348c23445390d58fb393f731acdee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824348c23445390d58fb393f731acdee">&#9670;&#160;</a></span>blocking()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables or disables blocking mode for a stream. </p>
<p>When blocking mode is enabled all writes complete synchronously. The interface remains unchanged otherwise, e.g. completion or failure of the operation will still be reported through events which are emitted asynchronously.</p>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_stream_set_blocking">documentation</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable blocking mode, false otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00451">451</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="ae1022648bbcdd62fa84a411aa80c1057" name="ae1022648bbcdd62fa84a411aa80c1057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1022648bbcdd62fa84a411aa80c1057">&#9670;&#160;</a></span>listen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::listen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em> = <code>DEFAULT_BACKLOG</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts listening for incoming connections. </p>
<p>When a new incoming connection is received, a listen event is emitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backlog</td><td>Indicates the number of connections the kernel might queue, same as listen(2).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00193">193</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a1fb471cfc6eec1dc2683e381ec828087" name="a1fb471cfc6eec1dc2683e381ec828087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb471cfc6eec1dc2683e381ec828087">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts reading data from an incoming stream. </p>
<p>A data event will be emitted several times until there is no more data to read or <code><a class="el" href="classuvw_1_1stream__handle.html#ae06ccaed032ab19ac2466ba35c5d1c9e" title="Stops reading data from the stream.">stop()</a></code> is called.<br  />
 An end event will be emitted when there is no more data to read.</p>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00230">230</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a459eccecaee81d4a8619e1a073e81a69" name="a459eccecaee81d4a8619e1a073e81a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459eccecaee81d4a8619e1a073e81a69">&#9670;&#160;</a></span>readable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::readable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the stream is readable. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the stream is readable, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00424">424</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a74a48d00b23a4bd5a231d3f8bfaa655d" name="a74a48d00b23a4bd5a231d3f8bfaa655d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a48d00b23a4bd5a231d3f8bfaa655d">&#9670;&#160;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shutdowns the outgoing (write) side of a duplex stream. </p>
<p>It waits for pending write requests to complete. The handle should refer to a initialized stream.<br  />
 A shutdown event will be emitted after shutdown is complete.</p>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00170">170</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="ae06ccaed032ab19ac2466ba35c5d1c9e" name="ae06ccaed032ab19ac2466ba35c5d1c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06ccaed032ab19ac2466ba35c5d1c9e">&#9670;&#160;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops reading data from the stream. </p>
<p>This function is idempotent and may be safely called on a stopped stream.</p>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00241">241</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a6d56a5108fd6f3fd7f11f7e5507c7727" name="a6d56a5108fd6f3fd7f11f7e5507c7727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d56a5108fd6f3fd7f11f7e5507c7727">&#9670;&#160;</a></span>try_write() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::try_write </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a write request if it can be completed immediately. </p>
<p>Same as <code><a class="el" href="classuvw_1_1stream__handle.html#ad8a3ac704e013ede496a3d998a74ebc7" title="Writes data to the stream.">write()</a></code>, but won’t queue a write request if it can’t be completed immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00399">399</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a729ff5d6b7da6af3c70068a3dfca5204" name="a729ff5d6b7da6af3c70068a3dfca5204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729ff5d6b7da6af3c70068a3dfca5204">&#9670;&#160;</a></span>try_write() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<div class="memtemplate">
template&lt;typename V , typename W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::try_write </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuvw_1_1stream__handle.html">stream_handle</a>&lt; V, W &gt; &amp;&#160;</td>
          <td class="paramname"><em>send</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a write request if it can be completed immediately. </p>
<p>Same as <code>try_write</code> for sending handles over a pipe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
    <tr><td class="paramname">send</td><td>A valid handle suitable for the purpose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00415">415</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="af07b07065609821932537dc23773b2ed" name="af07b07065609821932537dc23773b2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07b07065609821932537dc23773b2ed">&#9670;&#160;</a></span>try_write() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::try_write </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; char[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a write request if it can be completed immediately. </p>
<p>Same as <code><a class="el" href="classuvw_1_1stream__handle.html#ad8a3ac704e013ede496a3d998a74ebc7" title="Writes data to the stream.">write()</a></code>, but won’t queue a write request if it can’t be completed immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00368">368</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="aa0b12e5126cba8c84a3fdbb01cc3b81a" name="aa0b12e5126cba8c84a3fdbb01cc3b81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b12e5126cba8c84a3fdbb01cc3b81a">&#9670;&#160;</a></span>try_write() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<div class="memtemplate">
template&lt;typename V , typename W &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::try_write </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; char[]&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuvw_1_1stream__handle.html">stream_handle</a>&lt; V, W &gt; &amp;&#160;</td>
          <td class="paramname"><em>send</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a write request if it can be completed immediately. </p>
<p>Same as <code>try_write</code> for sending handles over a pipe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
    <tr><td class="paramname">send</td><td>A valid handle suitable for the purpose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00384">384</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a09ac22ea79bf27479eedbda9ac1101f0" name="a09ac22ea79bf27479eedbda9ac1101f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ac22ea79bf27479eedbda9ac1101f0">&#9670;&#160;</a></span>writable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::writable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the stream is writable. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the stream is writable, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00432">432</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="afd0895fadb7985f8b437ff3bce62a80b" name="afd0895fadb7985f8b437ff3bce62a80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0895fadb7985f8b437ff3bce62a80b">&#9670;&#160;</a></span>write() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::write </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to the stream. </p>
<p>Data are written in order. The handle doesn't take the ownership of the data. Be sure that their lifetime overcome the one of the request.</p>
<p>A write event will be emitted when the data have been written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00282">282</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="aace2532231266f660ad26876602eaad0" name="aace2532231266f660ad26876602eaad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace2532231266f660ad26876602eaad0">&#9670;&#160;</a></span>write() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::write </td>
          <td>(</td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extended write function for sending handles over a pipe handle. </p>
<p>The pipe must be initialized with <code>ipc == true</code>.</p>
<p><code>send</code> must be a tcp or pipe handle, which is a server or a connection (listening or connected state). Bound sockets or pipes will be assumed to be servers.</p>
<p>The handle doesn't take the ownership of the data. Be sure that their lifetime overcome the one of the request.</p>
<p>A write event will be emitted when the data have been written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>The handle over which to write data. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00346">346</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a28a943387b69c05b7bb6469f7042ca08" name="a28a943387b69c05b7bb6469f7042ca08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a943387b69c05b7bb6469f7042ca08">&#9670;&#160;</a></span>write() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<div class="memtemplate">
template&lt;typename S , typename Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::write </td>
          <td>(</td>
          <td class="paramtype">S &amp;&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; char[], Deleter &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extended write function for sending handles over a pipe handle. </p>
<p>The pipe must be initialized with <code>ipc == true</code>.</p>
<p><code>send</code> must be a tcp or pipe handle, which is a server or a connection (listening or connected state). Bound sockets or pipes will be assumed to be servers.</p>
<p>The handle takes the ownership of the data and it is in charge of delete them.</p>
<p>A write event will be emitted when the data have been written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>The handle over which to write data. </td></tr>
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00314">314</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="ad8a3ac704e013ede496a3d998a74ebc7" name="ad8a3ac704e013ede496a3d998a74ebc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a3ac704e013ede496a3d998a74ebc7">&#9670;&#160;</a></span>write() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<div class="memtemplate">
template&lt;typename Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::write </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; char[], Deleter &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes data to the stream. </p>
<p>Data are written in order. The handle takes the ownership of the data and it is in charge of delete them.</p>
<p>A write event will be emitted when the data have been written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to be written to the stream. </td></tr>
    <tr><td class="paramname">len</td><td>The lenght of the submitted data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00258">258</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<a id="a455c3e4cccd8f8119d1f251b809ea810" name="a455c3e4cccd8f8119d1f251b809ea810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455c3e4cccd8f8119d1f251b809ea810">&#9670;&#160;</a></span>write_queue_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classuvw_1_1stream__handle.html">uvw::stream_handle</a>&lt; T, U, E &gt;::write_queue_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the amount of queued bytes waiting to be sent. </p>
<dl class="section return"><dt>Returns</dt><dd>Amount of queued bytes waiting to be sent. </dd></dl>

<p class="definition">Definition at line <a class="el" href="stream_8h_source.html#l00459">459</a> of file <a class="el" href="stream_8h_source.html">stream.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/uvw/<a class="el" href="stream_8h_source.html">stream.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
