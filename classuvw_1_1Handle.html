<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uvw: uvw::handle&lt; T, U, E &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">uvw<span id="projectnumber">&#160;3.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceuvw.html">uvw</a></li><li class="navelem"><a class="el" href="classuvw_1_1handle.html">handle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classuvw_1_1handle-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">uvw::handle&lt; T, U, E &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Handle base class.  
 <a href="classuvw_1_1handle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="handle_8hpp_source.html">handle.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for uvw::handle&lt; T, U, E &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1handle__inherit__graph.png" border="0" usemap="#auvw_1_1handle_3_01T_00_01U_00_01E_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="auvw_1_1handle_3_01T_00_01U_00_01E_01_4_inherit__map" id="auvw_1_1handle_3_01T_00_01U_00_01E_01_4_inherit__map">
<area shape="rect" title="Handle base class." alt="" coords="393,77,548,102"/>
<area shape="rect" href="classuvw_1_1stream__handle.html" title=" " alt="" coords="596,5,773,45"/>
<area shape="rect" href="classuvw_1_1stream__handle.html" title=" " alt="" coords="602,69,767,109"/>
<area shape="rect" href="classuvw_1_1stream__handle.html" title=" " alt="" coords="605,133,764,173"/>
<area shape="rect" href="classuvw_1_1resource.html" title=" " alt="" coords="204,69,345,109"/>
<area shape="rect" href="structuvw_1_1uv__type.html" title="Wrapper class for underlying types." alt="" coords="17,51,145,77"/>
<area shape="rect" href="classuvw_1_1emitter.html" title=" " alt="" coords="5,101,156,126"/>
<area shape="rect" href="classuvw_1_1pipe__handle.html" title="The pipe handle." alt="" coords="821,13,941,38"/>
<area shape="rect" href="classuvw_1_1tcp__handle.html" title="The TCP handle." alt="" coords="824,77,939,102"/>
<area shape="rect" href="classuvw_1_1tty__handle.html" title="The tty handle." alt="" coords="826,141,937,166"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for uvw::handle&lt; T, U, E &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classuvw_1_1handle__coll__graph.png" border="0" usemap="#auvw_1_1handle_3_01T_00_01U_00_01E_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="auvw_1_1handle_3_01T_00_01U_00_01E_01_4_coll__map" id="auvw_1_1handle_3_01T_00_01U_00_01E_01_4_coll__map">
<area shape="rect" title="Handle base class." alt="" coords="73,167,228,192"/>
<area shape="rect" href="classuvw_1_1resource.html" title=" " alt="" coords="80,79,221,119"/>
<area shape="rect" href="structuvw_1_1uv__type.html" title="Wrapper class for underlying types." alt="" coords="5,5,133,31"/>
<area shape="rect" href="classuvw_1_1emitter.html" title=" " alt="" coords="158,5,309,31"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a80c5ba8c4db128cc525406e998549b96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#a9e28e1855691dd1af105626ed11f3ac4">handle_category</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a80c5ba8c4db128cc525406e998549b96">category</a> () const noexcept</td></tr>
<tr class="memdesc:a80c5ba8c4db128cc525406e998549b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the category of the handle.  <br /></td></tr>
<tr class="separator:a80c5ba8c4db128cc525406e998549b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88018be1fa3105e958c50a9f1881baa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#a3954d5751b5b6ebb0c90c195e9b94edd">handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a88018be1fa3105e958c50a9f1881baa9">type</a> () const noexcept</td></tr>
<tr class="memdesc:a88018be1fa3105e958c50a9f1881baa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of the handle.  <br /></td></tr>
<tr class="separator:a88018be1fa3105e958c50a9f1881baa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938d3ac6e5cc78f9442f9bb851170643"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a938d3ac6e5cc78f9442f9bb851170643">active</a> () const noexcept</td></tr>
<tr class="memdesc:a938d3ac6e5cc78f9442f9bb851170643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the handle is active.  <br /></td></tr>
<tr class="separator:a938d3ac6e5cc78f9442f9bb851170643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93cbf2156f0d673093e48832104a3cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#ae93cbf2156f0d673093e48832104a3cc">closing</a> () const noexcept</td></tr>
<tr class="memdesc:ae93cbf2156f0d673093e48832104a3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a handle is closing or closed.  <br /></td></tr>
<tr class="separator:ae93cbf2156f0d673093e48832104a3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3648ed9805e8d0e8963f137f8584e483"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a3648ed9805e8d0e8963f137f8584e483">close</a> () noexcept</td></tr>
<tr class="memdesc:a3648ed9805e8d0e8963f137f8584e483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request handle to be closed.  <br /></td></tr>
<tr class="separator:a3648ed9805e8d0e8963f137f8584e483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0d788997368ab1af2dc475126a46d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a2f0d788997368ab1af2dc475126a46d2">reference</a> () noexcept</td></tr>
<tr class="memdesc:a2f0d788997368ab1af2dc475126a46d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference the given handle.  <br /></td></tr>
<tr class="separator:a2f0d788997368ab1af2dc475126a46d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a91d1353c19f1a05aace78dc2cc453"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a83a91d1353c19f1a05aace78dc2cc453">unreference</a> () noexcept</td></tr>
<tr class="memdesc:a83a91d1353c19f1a05aace78dc2cc453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unreference the given handle.  <br /></td></tr>
<tr class="separator:a83a91d1353c19f1a05aace78dc2cc453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1403f961ab40063f79c4a293c78ed63c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a1403f961ab40063f79c4a293c78ed63c">referenced</a> () const noexcept</td></tr>
<tr class="memdesc:a1403f961ab40063f79c4a293c78ed63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given handle referenced.  <br /></td></tr>
<tr class="separator:a1403f961ab40063f79c4a293c78ed63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5852080ba1fd71a302c2424cf2df9a27"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a5852080ba1fd71a302c2424cf2df9a27">size</a> () const noexcept</td></tr>
<tr class="memdesc:a5852080ba1fd71a302c2424cf2df9a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the underlying handle type.  <br /></td></tr>
<tr class="separator:a5852080ba1fd71a302c2424cf2df9a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99406ca909aeaac17522959db8c71a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#aa99406ca909aeaac17522959db8c71a4">send_buffer_size</a> ()</td></tr>
<tr class="memdesc:aa99406ca909aeaac17522959db8c71a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the send buffer used for the socket.  <br /></td></tr>
<tr class="separator:aa99406ca909aeaac17522959db8c71a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917ab9c1f011232b50f9980f29167ee2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a917ab9c1f011232b50f9980f29167ee2">send_buffer_size</a> (int value)</td></tr>
<tr class="memdesc:a917ab9c1f011232b50f9980f29167ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the send buffer used for the socket.  <br /></td></tr>
<tr class="separator:a917ab9c1f011232b50f9980f29167ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3337ef0c68ed5ba0e9bea0e2e90539"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a7a3337ef0c68ed5ba0e9bea0e2e90539">recv_buffer_size</a> ()</td></tr>
<tr class="memdesc:a7a3337ef0c68ed5ba0e9bea0e2e90539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the receive buffer used for the socket.  <br /></td></tr>
<tr class="separator:a7a3337ef0c68ed5ba0e9bea0e2e90539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace23bb725f6f80ae7a611f5228ad9f8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#ace23bb725f6f80ae7a611f5228ad9f8d">recv_buffer_size</a> (int value)</td></tr>
<tr class="memdesc:ace23bb725f6f80ae7a611f5228ad9f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the receive buffer used for the socket.  <br /></td></tr>
<tr class="separator:ace23bb725f6f80ae7a611f5228ad9f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce9568c94aa0122ff4cee6a57b4fae5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceuvw.html#a1a4f79e341b89257a11403ee0739f2b4">os_file_descriptor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1handle.html#a0ce9568c94aa0122ff4cee6a57b4fae5">fd</a> () const</td></tr>
<tr class="memdesc:a0ce9568c94aa0122ff4cee6a57b4fae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the platform dependent file descriptor equivalent.  <br /></td></tr>
<tr class="separator:a0ce9568c94aa0122ff4cee6a57b4fae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1resource"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1resource')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1resource.html">uvw::resource&lt; T, U, close_event, E... &gt;</a></td></tr>
<tr class="memitem:a7c05e988ebaa14d1dbbc781951dc3a88 inherit pub_methods_classuvw_1_1resource"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; R &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1resource.html#a7c05e988ebaa14d1dbbc781951dc3a88">data</a> () const</td></tr>
<tr class="memdesc:a7c05e988ebaa14d1dbbc781951dc3a88 inherit pub_methods_classuvw_1_1resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets user-defined data. <code>uvw</code> won't use this field in any case.  <br /></td></tr>
<tr class="separator:a7c05e988ebaa14d1dbbc781951dc3a88 inherit pub_methods_classuvw_1_1resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759079eb405e5d2fda795d199d8efa80 inherit pub_methods_classuvw_1_1resource"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1resource.html#a759079eb405e5d2fda795d199d8efa80">data</a> (std::shared_ptr&lt; void &gt; udata)</td></tr>
<tr class="memdesc:a759079eb405e5d2fda795d199d8efa80 inherit pub_methods_classuvw_1_1resource"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets arbitrary data. <code>uvw</code> won't use this field in any case.  <br /></td></tr>
<tr class="separator:a759079eb405e5d2fda795d199d8efa80 inherit pub_methods_classuvw_1_1resource"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structuvw_1_1uv__type"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structuvw_1_1uv__type')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structuvw_1_1uv__type.html">uvw::uv_type&lt; U &gt;</a></td></tr>
<tr class="memitem:ae97ffacc0b381610d8d18a62a957a69c inherit pub_methods_structuvw_1_1uv__type"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1uv__type.html#ae97ffacc0b381610d8d18a62a957a69c">init</a> ()</td></tr>
<tr class="memdesc:ae97ffacc0b381610d8d18a62a957a69c inherit pub_methods_structuvw_1_1uv__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the handle.  <br /></td></tr>
<tr class="separator:ae97ffacc0b381610d8d18a62a957a69c inherit pub_methods_structuvw_1_1uv__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03b0ebbae151c6157c5ba6a24a39a7b inherit pub_methods_structuvw_1_1uv__type"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuvw_1_1loop.html">loop</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1uv__type.html#ae03b0ebbae151c6157c5ba6a24a39a7b">parent</a> () const noexcept</td></tr>
<tr class="memdesc:ae03b0ebbae151c6157c5ba6a24a39a7b inherit pub_methods_structuvw_1_1uv__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the loop from which the resource was originated.  <br /></td></tr>
<tr class="separator:ae03b0ebbae151c6157c5ba6a24a39a7b inherit pub_methods_structuvw_1_1uv__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a6cb7ebde27aa348e340b76e49c6ae inherit pub_methods_structuvw_1_1uv__type"><td class="memItemLeft" align="right" valign="top">const U *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1uv__type.html#a06a6cb7ebde27aa348e340b76e49c6ae">raw</a> () const noexcept</td></tr>
<tr class="memdesc:a06a6cb7ebde27aa348e340b76e49c6ae inherit pub_methods_structuvw_1_1uv__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <br /></td></tr>
<tr class="separator:a06a6cb7ebde27aa348e340b76e49c6ae inherit pub_methods_structuvw_1_1uv__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b6f395815f2e99302b5f09be23767c inherit pub_methods_structuvw_1_1uv__type"><td class="memItemLeft" align="right" valign="top">U *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuvw_1_1uv__type.html#af4b6f395815f2e99302b5f09be23767c">raw</a> () noexcept</td></tr>
<tr class="memdesc:af4b6f395815f2e99302b5f09be23767c inherit pub_methods_structuvw_1_1uv__type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the underlying raw data structure.  <br /></td></tr>
<tr class="separator:af4b6f395815f2e99302b5f09be23767c inherit pub_methods_structuvw_1_1uv__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classuvw_1_1emitter"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classuvw_1_1emitter')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classuvw_1_1emitter.html">uvw::emitter&lt; T, E... &gt;</a></td></tr>
<tr class="memitem:ab913fa1c005a33c73b2eb2b0d1051b1f inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1emitter.html#ab913fa1c005a33c73b2eb2b0d1051b1f">on</a> (listener_t&lt; U &gt; f)</td></tr>
<tr class="memdesc:ab913fa1c005a33c73b2eb2b0d1051b1f inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a long-lived listener with the event emitter.  <br /></td></tr>
<tr class="separator:ab913fa1c005a33c73b2eb2b0d1051b1f inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accff5c096692f5eebbe941189644e69d inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top"><a id="accff5c096692f5eebbe941189644e69d" name="accff5c096692f5eebbe941189644e69d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> () noexcept</td></tr>
<tr class="memdesc:accff5c096692f5eebbe941189644e69d inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects the listener for the given event type. <br /></td></tr>
<tr class="separator:accff5c096692f5eebbe941189644e69d inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71435e74e775cfa7012fe2e52ca5193 inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top"><a id="aa71435e74e775cfa7012fe2e52ca5193" name="aa71435e74e775cfa7012fe2e52ca5193"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> () noexcept</td></tr>
<tr class="memdesc:aa71435e74e775cfa7012fe2e52ca5193 inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects all listeners. <br /></td></tr>
<tr class="separator:aa71435e74e775cfa7012fe2e52ca5193 inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02a29fe156faba7571b50450fc4f780 inherit pub_methods_classuvw_1_1emitter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuvw_1_1emitter.html#ac02a29fe156faba7571b50450fc4f780">has</a> () const noexcept</td></tr>
<tr class="memdesc:ac02a29fe156faba7571b50450fc4f780 inherit pub_methods_classuvw_1_1emitter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is a listener registered for the specific event.  <br /></td></tr>
<tr class="separator:ac02a29fe156faba7571b50450fc4f780 inherit pub_methods_classuvw_1_1emitter"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename U, typename... E&gt;<br />
class uvw::handle&lt; T, U, E &gt;</div><p>Handle base class. </p>
<p>Base type for all <code>uvw</code> handle types. </p>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00023">23</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a938d3ac6e5cc78f9442f9bb851170643" name="a938d3ac6e5cc78f9442f9bb851170643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938d3ac6e5cc78f9442f9bb851170643">&#9670;&#160;</a></span>active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classuvw_1_1handle.html">uvw::handle</a>&lt; T, U, E &gt;::active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the handle is active. </p>
<p>What <em>active</em> means depends on the type of handle:</p>
<ul>
<li>An <a class="el" href="classuvw_1_1async__handle.html" title="The async handle.">async_handle</a> handle is always active and cannot be deactivated, except by closing it with uv_close().</li>
<li>A pipe, tcp, udp, etc. handle - basically any handle that deals with I/O - is active when it is doing something that involves I/O, like reading, writing, connecting, accepting new connections, etc.</li>
<li>A check, idle, timer, etc. handle is active when it has been started with a call to <code>start()</code>.</li>
</ul>
<p>Rule of thumb: if a handle of type <code>foo_handle</code> has a <code>start()</code> member method, then it’s active from the moment that method is called. Likewise, <code>stop()</code> deactivates the handle again.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the handle is active, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00088">88</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="a80c5ba8c4db128cc525406e998549b96" name="a80c5ba8c4db128cc525406e998549b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c5ba8c4db128cc525406e998549b96">&#9670;&#160;</a></span>category()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceuvw.html#a9e28e1855691dd1af105626ed11f3ac4">handle_category</a> <a class="el" href="classuvw_1_1handle.html">uvw::handle</a>&lt; T, U, E &gt;::category </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the category of the handle. </p>
<p>A base handle offers no functionality to promote it to the actual handle type. By means of this function, an opaque value that identifies the category of the handle is made available to the users.</p>
<dl class="section return"><dt>Returns</dt><dd>The actual category of the handle. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00052">52</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="a3648ed9805e8d0e8963f137f8584e483" name="a3648ed9805e8d0e8963f137f8584e483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3648ed9805e8d0e8963f137f8584e483">&#9670;&#160;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1handle.html">uvw::handle</a>&lt; T, U, E &gt;::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request handle to be closed. </p>
<p>This <b>must</b> be called on each handle before memory is released.<br  />
 In-progress requests are cancelled and this can result in errors.</p>
<p>The handle will emit a close event when finished. </p>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00112">112</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="ae93cbf2156f0d673093e48832104a3cc" name="ae93cbf2156f0d673093e48832104a3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93cbf2156f0d673093e48832104a3cc">&#9670;&#160;</a></span>closing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classuvw_1_1handle.html">uvw::handle</a>&lt; T, U, E &gt;::closing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a handle is closing or closed. </p>
<p>This function should only be used between the initialization of the handle and the arrival of the close callback.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the handle is closing or closed, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00100">100</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="a0ce9568c94aa0122ff4cee6a57b4fae5" name="a0ce9568c94aa0122ff4cee6a57b4fae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce9568c94aa0122ff4cee6a57b4fae5">&#9670;&#160;</a></span>fd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceuvw.html#a1a4f79e341b89257a11403ee0739f2b4">os_file_descriptor</a> <a class="el" href="classuvw_1_1handle.html">uvw::handle</a>&lt; T, U, E &gt;::fd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the platform dependent file descriptor equivalent. </p>
<p>Supported handles:</p>
<ul>
<li><a class="el" href="classuvw_1_1tcp__handle.html" title="The TCP handle.">tcp_handle</a></li>
<li><a class="el" href="classuvw_1_1pipe__handle.html" title="The pipe handle.">pipe_handle</a></li>
<li><a class="el" href="classuvw_1_1tty__handle.html" title="The tty handle.">tty_handle</a></li>
<li><a class="el" href="classuvw_1_1udp__handle.html" title="The UDP handle.">udp_handle</a></li>
<li><a class="el" href="classuvw_1_1poll__handle.html" title="The poll handle.">poll_handle</a></li>
</ul>
<p>If invoked on a different handle, one that doesn’t have an attached file descriptor yet or one which was closed, an invalid value is returned.</p>
<p>See the official <a href="http://docs.libuv.org/en/v1.x/handle.html#c.uv_fileno">documentation</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>The file descriptor attached to the hande or a negative value in case of errors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00241">241</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="a7a3337ef0c68ed5ba0e9bea0e2e90539" name="a7a3337ef0c68ed5ba0e9bea0e2e90539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3337ef0c68ed5ba0e9bea0e2e90539">&#9670;&#160;</a></span>recv_buffer_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1handle.html">uvw::handle</a>&lt; T, U, E &gt;::recv_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the receive buffer used for the socket. </p>
<p>Gets the size of the receive buffer that the operating system uses for the socket.<br  />
 This function works for tcp, pipe and udp handles on Unix and for tcp and udp handles on Windows.<br  />
 Note that Linux will return double the size of the original set value.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the receive buffer, the underlying return value in case of errors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00199">199</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="ace23bb725f6f80ae7a611f5228ad9f8d" name="ace23bb725f6f80ae7a611f5228ad9f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace23bb725f6f80ae7a611f5228ad9f8d">&#9670;&#160;</a></span>recv_buffer_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1handle.html">uvw::handle</a>&lt; T, U, E &gt;::recv_buffer_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the size of the receive buffer used for the socket. </p>
<p>Sets the size of the receive buffer that the operating system uses for the socket.<br  />
 This function works for tcp, pipe and udp handles on Unix and for tcp and udp handles on Windows.<br  />
 Note that Linux will set double the size.</p>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00216">216</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="a2f0d788997368ab1af2dc475126a46d2" name="a2f0d788997368ab1af2dc475126a46d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0d788997368ab1af2dc475126a46d2">&#9670;&#160;</a></span>reference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1handle.html">uvw::handle</a>&lt; T, U, E &gt;::reference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference the given handle. </p>
<p>References are idempotent, that is, if a handle is already referenced calling this function again will have no effect. </p>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00124">124</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="a1403f961ab40063f79c4a293c78ed63c" name="a1403f961ab40063f79c4a293c78ed63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1403f961ab40063f79c4a293c78ed63c">&#9670;&#160;</a></span>referenced()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classuvw_1_1handle.html">uvw::handle</a>&lt; T, U, E &gt;::referenced </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given handle referenced. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the handle referenced, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00142">142</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="aa99406ca909aeaac17522959db8c71a4" name="aa99406ca909aeaac17522959db8c71a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99406ca909aeaac17522959db8c71a4">&#9670;&#160;</a></span>send_buffer_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1handle.html">uvw::handle</a>&lt; T, U, E &gt;::send_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the send buffer used for the socket. </p>
<p>Gets the size of the send buffer that the operating system uses for the socket.<br  />
 This function works for tcp, pipeand udp handles on Unix and for tcp and udp handles on Windows.<br  />
 Note that Linux will return double the size of the original set value.</p>
<dl class="section return"><dt>Returns</dt><dd>The size of the send buffer, the underlying return value in case of errors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00166">166</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="a917ab9c1f011232b50f9980f29167ee2" name="a917ab9c1f011232b50f9980f29167ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917ab9c1f011232b50f9980f29167ee2">&#9670;&#160;</a></span>send_buffer_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classuvw_1_1handle.html">uvw::handle</a>&lt; T, U, E &gt;::send_buffer_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the size of the send buffer used for the socket. </p>
<p>Sets the size of the send buffer that the operating system uses for the socket.<br  />
 This function works for tcp, pipe and udp handles on Unix and for tcp and udp handles on Windows.<br  />
 Note that Linux will set double the size.</p>
<dl class="section return"><dt>Returns</dt><dd>Underlying return value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00183">183</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="a5852080ba1fd71a302c2424cf2df9a27" name="a5852080ba1fd71a302c2424cf2df9a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5852080ba1fd71a302c2424cf2df9a27">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classuvw_1_1handle.html">uvw::handle</a>&lt; T, U, E &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the underlying handle type. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the underlying handle type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00150">150</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="a88018be1fa3105e958c50a9f1881baa9" name="a88018be1fa3105e958c50a9f1881baa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88018be1fa3105e958c50a9f1881baa9">&#9670;&#160;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceuvw.html#a3954d5751b5b6ebb0c90c195e9b94edd">handle_type</a> <a class="el" href="classuvw_1_1handle.html">uvw::handle</a>&lt; T, U, E &gt;::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the type of the handle. </p>
<p>A base handle offers no functionality to promote it to the actual handle type. By means of this function, the type of the underlying handle as specified by handle_type is made available to the users.</p>
<dl class="section return"><dt>Returns</dt><dd>The actual type of the handle. </dd></dl>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00065">65</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<a id="a83a91d1353c19f1a05aace78dc2cc453" name="a83a91d1353c19f1a05aace78dc2cc453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a91d1353c19f1a05aace78dc2cc453">&#9670;&#160;</a></span>unreference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classuvw_1_1handle.html">uvw::handle</a>&lt; T, U, E &gt;::unreference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unreference the given handle. </p>
<p>References are idempotent, that is, if a handle is not referenced calling this function again will have no effect. </p>

<p class="definition">Definition at line <a class="el" href="handle_8hpp_source.html#l00134">134</a> of file <a class="el" href="handle_8hpp_source.html">handle.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/uvw/<a class="el" href="handle_8hpp_source.html">handle.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
